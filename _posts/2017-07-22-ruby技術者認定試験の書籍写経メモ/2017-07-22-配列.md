## 配列 Array

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### あまりやらない初期化の方法

Array.newに数値を渡すと、指定したサイズの "全ての要素がnilの配列" が作成される

```ruby
Array.new(3)
=> [nil, nil, nil]
```

Array.newに数値とオブジェクトを渡すと、指定したサイズの "全ての要素が指定したオブジェクトな配列" が作成される。その動作が本当に必要な場面はあまりないだろう

```ruby
a = 'moko'
a.object_id
=> 70271478704800

as = Array.new(3, a)
=> ["moko", "moko", "moko"]

as[0].object_id
=> 70271478704800
as[1].object_id
=> 70271478704800
```

Array.newに数値とブロックを渡すとイテレート毎にオブジェクトが作られ、それを指す配列が作成される

```ruby
as = Array.new(3) { 'moko' }
=> ["moko", "moko", "moko"]

as[0].object_id
=> 70271479084700
as[1].object_id
=> 70271479084680
```

```ruby
Array.new(3) { |index| "moko#{index}" }
=> ["moko0", "moko1", "moko2"]
```

配列の添字に2つ数値を指定すると[開始場所、長さ]の指定となる

```ruby
[0, 1, 2, 3, 4][2, 3]
=> [2, 3, 4]
```

配列の添字に2つ数値を指定、代入すると指定した長さの部分が代入したオブジェクトへ置き換わる

```ruby
as = [0, 1, 2, 3, 4]
as[1, 2] = '50'
as
=> [0, '50', 3, 4]
```

配列を渡すと元の配列より長くなったりも可能

```ruby
as = [0, 1, 2, 3, 4]
as[1, 2] = ['50', '51', '53']
as
=> [0, '50', '51', '53', 3, 4]

as = [0, 1, 2, 3, 4]
as[1, 2] = '60', '61', '63'
as
=> [0, "60", "61", "63", 3, 4]
```

単純な挿入みたいな動きにもできる

```ruby
as = [0, 1, 2, 3, 4]
as[1, 0] = ['71', '72']
as
=> [0, "71", "72", 1, 2, 3, 4]
```

空の配列を渡すと削除的な動きになる

```ruby
as = [0, 1, 2, 3, 4]
as[1, 2] = []
as
=> [0, 3, 4]
```

### 多重代入

```ruby
a, b, c = 10, 20, 30
a #=> 10
b #=> 20
c #=> 30
```

配列でもいいよ

```ruby
a, b, c = [10, 20, 30]
a #=> 10
b #=> 20
c #=> 30
```

メソッドの戻り値でも使える

```ruby
def hage
  return 10, 20, 30
end
a, b, c = hage
a #=> 10
b #=> 20
c #=> 30
```

変数の数が違うと

```ruby
a, b = 10, 20, 30
a #=> 10
b #=> 20

a, b, c = 10, 20
a #=> 10
b #=> 20
c #=> nil
```

代入先が1つなら

```ruby
a = 10, 20, 30
a
=> [10, 20, 30]
```

変則的な多重代入

```ruby
a, b, c = [10, 20], 30
a #=> [10, 20]
b #=> 30
c #=> nil

(a, b), c = [10, 20], 30
a #=> 10
b #=> 20
c #=> 30
```

メソッドの仮引数、実引数の関係にも同じ感じのルールが適用される
- [メソッド](./メソッド.md)

### Array#&, Array#|, Array#+, Array#-, Array#*

&&, and, ||, or は無いよ 論理演算子だからね

```ruby
[1, 2, 3, 4] & [3, 4, 5, 6] #=> [3, 4]
[1, 2, 3, 4] | [3, 4, 5, 6] #=> [1, 2, 3, 4, 5, 6]
[1, 2, 3, 4] + [3, 4, 5, 6] #=> [1, 2, 3, 4, 3, 4, 5, 6]
[1, 2, 3, 4] - [3, 4, 5, 6] #=> [1, 2]
[1, 1, 3, 4] - [1, 2]       #=> [3, 4]
[1, 2, 3, 4] * 2            #=> [1, 2, 3, 4, 1, 2, 3, 4]
[1, 2, 3, 4] * '_'          #=> "1_2_3_4" # :joinと同じ動作 マジかよ
```

### Array#concat, Array#<<, Array#push, Array#pop, Array#shift, Array#unshift

はかいてき

| concat  | 1つ以上の | 配列を受け取り         | 配列の末尾 | に配列を連結                             |
| <<      | 1つの     | オブジェクトを受け取り | 配列の末尾 | にオブジェクトを連結                     |
| push    | 1つ以上の | オブジェクトを受け取り | 配列の末尾 | にオブジェクトを連結                     |
| pop     |           |                        | 配列の末尾 | からオブジェクトを指定した数だけ取り出す |
| shift   |           |                        | 配列の頭   | からオブジェクトを指定した数だけ取り出す |
| unshift | 1つ以上の | オブジェクトを受け取り | 配列の頭   | にオブジェクトを連結                     |

```ruby
# 配列の末尾に配列を破壊的に連結、引数はもちろん配列
a = [1, 2, 3]
a.concat(4)
TypeError: no implicit conversion of Integer into Array

a = [1, 2, 3]
a.concat([4])
a #=> [1, 2, 3, 4]
```

```ruby
# 配列の末尾にオブジェクトを破壊的に連結、引数は1つのみ
a = [1, 2, 3]
a << 4
a #=> [1, 2, 3, 4]

a = [1, 2, 3]
a << [4]
a #=> [1, 2, 3, [4]]

a = [1, 2, 3]
a << 4, 5
SyntaxError: syntax error, unexpected ',', expecting end-of-input
```

```ruby
# 配列の末尾にオブジェクトを破壊的に連結、引数は複数指定可能
a = [1, 2, 3]
a.push(4)
a #=> [1, 2, 3, 4]

a = [1, 2, 3]
a.push([4])
a #=> [1, 2, 3, [4]]

a = [1, 2, 3]
a.push(*[4, 5]) # 配列の引数展開・・キモい
=> [1, 2, 3, 4, 5]

a = [1, 2, 3]
a.push(4, 5)
=> [1, 2, 3, 4, 5]
```

```ruby
# 配列の末尾から要素を破壊的に取り出す、引数にて取り出す個数を指定できる
a = [1, 2, 3]
a.pop #=> 3
a #=> [1, 2]

a = [1, 2, 3]
a.pop(2) #=> [2, 3]
a #=> [1]

a = [1, 2, 3]
a.pop(3) #=> [1, 2, 3]
a #=> []

a = [1, 2, 3]
a.pop(4) #=> [1, 2, 3]
a #=> []

a = []
a.pop #=> nil
a #=> []
```

```ruby
# 配列の頭から要素を破壊的に取り出す、引数にて取り出す個数を指定できる
a = [1, 2, 3]
a.shift #=> 1
a #=> [2, 3]

a = [1, 2, 3]
a.shift(2) #=> [1, 2]
a #=> [3]

a = [1, 2, 3]
a.shift(3) #=> [1, 2, 3]
a #=> []

a = [1, 2, 3]
a.shift(4) #=> [1, 2, 3]
a #=> []

a = []
a.shift #=> nil
a #=> []
```

```ruby
# 配列の頭にオブジェクトを破壊的に連結、引数は複数指定可能
a = [1, 2, 3]
a.unshift(4)
a #=> [4, 1, 2, 3]

a = [1, 2, 3]
a.unshift([4])
a #=> [[4], 1, 2, 3]

a = [1, 2, 3]
a.unshift(4, 5)
=> [4, 5, 1, 2, 3]
```

### イテレート （配列専用、という事ではないが、ここに書いておこう）

### for

forはスコープを作らないので、アクセスし放題

```ruby
moko = 1
for a in [1, 2, 3]
  p moko #=> 1
end
p moko #=> 1
for a in [1, 2, 3]
  moko = a
  homo = a
end
p moko #=> 3
p homo #=> 3
```

### each

スコープを作るので、内部で初期化したローカル変数は外には漏れ出さない
```ruby
moko = 1
[1, 2, 3].each do
  p moko #=> 1
end
p moko #=> 1
[1, 2, 3].each do |a|
  moko = a
  homo = a
end
p moko #=> 3
p homo
NameError: undefined local variable or method 'homo'
```
