## 配列 Array

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### 配列の生成

#### リテラル

これを使えばおｋ

```ruby
a = [1, 2, 3]

a.class
=> Array
```

#### Array.[] に要素を渡すと配列が作成される

この方法は積極的に使う理由がない限り使いません

```ruby
Array[1 , 2, 3]
=> [1, 2, 3]
```

#### Array.newに数値を渡すと、指定したサイズの "全ての要素がnilの配列" が作成される

この方法は積極的に使う理由がない限り使いません

```ruby
Array.new(3)
=> [nil, nil, nil]
```

#### Array.newに配列を渡すと、渡した配列が複製されます

- もちろん要素は同じオブジェクトを指しています
- この方法は積極的に使う理由がない限り使いません

```ruby
a = ['a', 'b', 'c']

c = Array.new(a)

a.object_id
=> 70321659644240
c.object_id
=> 70321659578860

a[1].object_id
=> 70321654905680
c[1].object_id
=> 70321654905680
```

#### Array.newに数値とオブジェクトを渡すと、指定したサイズの "全ての要素が指定したオブジェクトな配列" が作成される

この動作が本当に必要な場面はあまりないだろう

```ruby
a = 'moko'
a.object_id
=> 70271478704800

as = Array.new(3, a)
=> ["moko", "moko", "moko"]

as[0].object_id
=> 70271478704800
as[1].object_id
=> 70271478704800
```

#### Array.newに数値とブロックを渡すとイテレート毎にオブジェクトが作られ、それを指す配列が作成される

```ruby
as = Array.new(3) { 'moko' }
=> ["moko", "moko", "moko"]

as[0].object_id
=> 70271479084700
as[1].object_id
=> 70271479084680
```

```ruby
Array.new(3) { |index| "moko#{index}" }
=> ["moko0", "moko1", "moko2"]
```

### 配列の添字に数値を指定して値にアクセスする

```ruby
['a', 'b', 'c'][0]
=> "a"

a = ['a', 'b', 'c']
a[1] = 'z'
a
=> ["a", "z", "c"]
```

要素数よりも大きな値が指定された場合には自動的に配列の長さが伸長される

```ruby
a = ['a', 'b', 'c']
a[10] = 'z'
a
=> ["a", "b", "c", nil, nil, nil, nil, nil, nil, nil, "z"]
```

### 配列の添字に2つ数値を指定すると[開始場所、長さ]の指定となる

```ruby
[0, 1, 2, 3, 4][2, 3]
=> [2, 3, 4]
```

### 多重代入

```ruby
a, b, c = 10, 20, 30
a #=> 10
b #=> 20
c #=> 30
```

配列でもいいよ

```ruby
a, b, c = [10, 20, 30]
a #=> 10
b #=> 20
c #=> 30
```

メソッドの戻り値でも使える

```ruby
def hage
  return 10, 20, 30
end
a, b, c = hage
a #=> 10
b #=> 20
c #=> 30
```

変数の数が違うと

```ruby
a, b = 10, 20, 30
a #=> 10
b #=> 20

a, b, c = 10, 20
a #=> 10
b #=> 20
c #=> nil
```

代入先が1つなら

```ruby
a = 10, 20, 30
a
=> [10, 20, 30]
```

変則的な多重代入

```ruby
a, b, c = [10, 20], 30
a #=> [10, 20]
b #=> 30
c #=> nil

(a, b), c = [10, 20], 30
a #=> 10
b #=> 20
c #=> 30
```

メソッドの仮引数、実引数の関係にも同じ感じのルールが適用される
- [メソッド](./メソッド.md)

### Array#&, Array#|, Array#+, Array#-, Array#*

&&, and, ||, or は無いよ 論理演算子だからね

```ruby
[1, 2, 3, 4] & [3, 4, 5, 6] #=> [3, 4]
[1, 2, 3, 4] | [3, 4, 5, 6] #=> [1, 2, 3, 4, 5, 6]
[1, 2, 3, 4] + [3, 4, 5, 6] #=> [1, 2, 3, 4, 3, 4, 5, 6]
[1, 2, 3, 4] - [3, 4, 5, 6] #=> [1, 2]
[1, 1, 3, 4] - [1, 2]       #=> [3, 4]
[1, 2, 3, 4] * 2            #=> [1, 2, 3, 4, 1, 2, 3, 4]
[1, 2, 3, 4] * '_'          #=> "1_2_3_4" # :joinと同じ動作 マジかよ
```

### 配列の要素を追加したり取り出したり

破壊的メソッド

| concat  | 1つ以上の | 配列を受け取り         | 配列の末尾            | に配列を連結                             |
| \<<     | 1つの     | オブジェクトを受け取り | 配列の末尾            | にオブジェクトを連結                     |
| push    | 1つ以上の | オブジェクトを受け取り | 配列の末尾            | にオブジェクトを連結                     |
| pop     |           |                        | 配列の末尾            | からオブジェクトを指定した数だけ取り出す |
| shift   |           |                        | 配列の頭              | からオブジェクトを指定した数だけ取り出す |
| unshift | 1つ以上の | オブジェクトを受け取り | 配列の頭              | にオブジェクトを連結                     |
| insert  | 1つの     | オブジェクトを受け取り | 第1引数で指定した場所 | にオブジェクトを挿入                     |

#### concat メソッド

```ruby
# 配列の末尾に配列を破壊的に連結、引数はもちろん配列
a = [1, 2, 3]
a.concat(4)
TypeError: no implicit conversion of Integer into Array

a = [1, 2, 3]
a.concat([4])
a
=> [1, 2, 3, 4]
```

#### \<< メソッド

```ruby
# 配列の末尾にオブジェクトを破壊的に連結、引数は1つのみ
a = [1, 2, 3]
a << 4
a
=> [1, 2, 3, 4]

a = [1, 2, 3]
a << [4]
a
=> [1, 2, 3, [4]]

a = [1, 2, 3]
a << 4, 5
SyntaxError: syntax error, unexpected ',', expecting end-of-input
```

#### push メソッド

```ruby
# 配列の末尾にオブジェクトを破壊的に連結、引数は複数指定可能
a = [1, 2, 3]
a.push(4)
a
=> [1, 2, 3, 4]

a = [1, 2, 3]
a.push([4])
a
=> [1, 2, 3, [4]]

a = [1, 2, 3]
a.push(*[4, 5]) # 配列の引数展開・・キモい
=> [1, 2, 3, 4, 5]

a = [1, 2, 3]
a.push(4, 5)
=> [1, 2, 3, 4, 5]
```

#### pop メソッド

```ruby
# 配列の末尾から要素を破壊的に取り出す、引数にて取り出す個数を指定できる
a = [1, 2, 3]
a.pop #=> 3
a
=> [1, 2]

a = [1, 2, 3]
a.pop(2) #=> [2, 3]
a
=> [1]

a = [1, 2, 3]
a.pop(3) #=> [1, 2, 3]
a
=> []

a = [1, 2, 3]
a.pop(4) #=> [1, 2, 3]
a
=> []

a = []
a.pop #=> nil
a
=> []
```

#### shift メソッド

```ruby
# 配列の頭から要素を破壊的に取り出す、引数にて取り出す個数を指定できる
a = [1, 2, 3]
a.shift #=> 1
a
=> [2, 3]

a = [1, 2, 3]
a.shift(2) #=> [1, 2]
a
=> [3]

a = [1, 2, 3]
a.shift(3) #=> [1, 2, 3]
a
=> []

a = [1, 2, 3]
a.shift(4) #=> [1, 2, 3]
a
=> []

a = []
a.shift #=> nil
a
=> []
```
