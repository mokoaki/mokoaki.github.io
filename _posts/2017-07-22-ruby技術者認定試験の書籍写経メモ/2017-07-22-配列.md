## 配列 Array

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### 配列の生成

#### リテラル

これを使えばおｋ

```ruby
a = [1, 2, 3]

a.class
=> Array
```

#### Array.[] に要素を渡すと配列が作成される

この方法は積極的に使う理由がない限り使いません

```ruby
Array[1 , 2, 3]
=> [1, 2, 3]
```

#### Array.newに数値を渡すと、指定したサイズの "全ての要素がnilの配列" が作成される

この方法は積極的に使う理由がない限り使いません

```ruby
Array.new(3)
=> [nil, nil, nil]
```

#### Array.newに配列を渡すと、渡した配列が複製されます

- もちろん要素は同じオブジェクトを指しています
- この方法は積極的に使う理由がない限り使いません

```ruby
a = ['a', 'b', 'c']

c = Array.new(a)

a.object_id
=> 70321659644240
c.object_id
=> 70321659578860

a[1].object_id
=> 70321654905680
c[1].object_id
=> 70321654905680
```

#### Array.newに数値とオブジェクトを渡すと、指定したサイズの "全ての要素が指定したオブジェクトな配列" が作成される

この動作が本当に必要な場面はあまりないだろう

```ruby
a = 'moko'
a.object_id
=> 70271478704800

as = Array.new(3, a)
=> ["moko", "moko", "moko"]

as[0].object_id
=> 70271478704800
as[1].object_id
=> 70271478704800
```

#### Array.newに数値とブロックを渡すとイテレート毎にオブジェクトが作られ、それを指す配列が作成される

```ruby
as = Array.new(3) { 'moko' }
=> ["moko", "moko", "moko"]

as[0].object_id
=> 70271479084700
as[1].object_id
=> 70271479084680
```

```ruby
Array.new(3) { |index| "moko#{index}" }
=> ["moko0", "moko1", "moko2"]
```

### 配列の添字に数値を指定して値にアクセスする

```ruby
['a', 'b', 'c'][0]
=> "a"

a = ['a', 'b', 'c']
a[1] = 'z'
a
=> ["a", "z", "c"]
```

要素数よりも大きな値が指定された場合には自動的に配列の長さが伸長される

```ruby
a = ['a', 'b', 'c']
a[10] = 'z'
a
=> ["a", "b", "c", nil, nil, nil, nil, nil, nil, nil, "z"]
```

### 配列の添字に2つ数値を指定すると[開始場所、長さ]の指定となる

```ruby
[0, 1, 2, 3, 4][2, 3]
=> [2, 3, 4]
```

### 多重代入

```ruby
a, b, c = 10, 20, 30
a #=> 10
b #=> 20
c #=> 30
```

配列でもいいよ

```ruby
a, b, c = [10, 20, 30]
a #=> 10
b #=> 20
c #=> 30
```

メソッドの戻り値でも使える

```ruby
def hage
  return 10, 20, 30
end
a, b, c = hage
a #=> 10
b #=> 20
c #=> 30
```

変数の数が違うと

```ruby
a, b = 10, 20, 30
a #=> 10
b #=> 20

a, b, c = 10, 20
a #=> 10
b #=> 20
c #=> nil
```

代入先が1つなら

```ruby
a = 10, 20, 30
a
=> [10, 20, 30]
```

変則的な多重代入

```ruby
a, b, c = [10, 20], 30
a #=> [10, 20]
b #=> 30
c #=> nil

(a, b), c = [10, 20], 30
a #=> 10
b #=> 20
c #=> 30
```

### Array#&, Array#|, Array#+, Array#-, Array#*

&&, and, ||, or は無いよ 論理演算子だからね

```ruby
[1, 2, 3, 4] & [3, 4, 5, 6] #=> [3, 4]
[1, 2, 3, 4] | [3, 4, 5, 6] #=> [1, 2, 3, 4, 5, 6]
[1, 2, 3, 4] + [3, 4, 5, 6] #=> [1, 2, 3, 4, 3, 4, 5, 6]
[1, 2, 3, 4] - [3, 4, 5, 6] #=> [1, 2]
[1, 1, 3, 4] - [1, 2]       #=> [3, 4]
[1, 2, 3, 4] * 2            #=> [1, 2, 3, 4, 1, 2, 3, 4]
[1, 2, 3, 4] * '_'          #=> "1_2_3_4" # :joinと同じ動作 マジかよ
```

### 配列の要素を参照する

| []        | slice |
| at        | 　    |
| fetch     | 　    |
| values_at | 　    |
| first     | 　    |
| last      | 　    |
| assoc     | 　    |
| rassoc    | 　    |

#### [] slice メソッド

整数、Rangeオブジェクト、始点終点で指定したインデックスに対応する要素を返す

```ruby
a = [1, 2, 3]

a[1]
=> 2

a[1, 2]
=> [2, 3]

a[1..2]
=> [2, 3]
```

```ruby
a = [1, 2, 3]

a.slice(1)
=> 2

a.slice(1, 2)
=> [2, 3]

a.slice(1..2)
=> [2, 3]
```

#### at メソッド

整数でインデックスを指定できるだけ

```ruby
a = [1, 2, 3]

a.at(1)
=> 2

a.at(10)
=> nil
```

#### fetch メソッド

- 整数でインデックスを指定できるだけ
- 要素数を超える場合の振る舞いがatメソッドと違う
  - 引数がインデックスのみの場合、IndexError例外が発生
  - 引数が2つの場合、第2引数を返す
  - ブロックを取っている場合には、その評価結果を返す

```ruby
a = [1, 2, 3]

a.fetch(1)
=> 2

a.fetch(10)
IndexError: index 10 outside of array bounds

a.fetch(10, 'aaa')
=> "aaa"

a.fetch(10) do |index|
  index + 5
end
=> 15
```

#### values_at メソッド

- 整数、Rangeオブジェクト、始点終点で指定したインデックスに対応する要素を返す
- 整数でインデックスを指定した場合でも単品の配列として値が帰ってくる

```ruby
a = [1, 2, 3]

a.values_at(1)
=> [2] # ここが違う

a.values_at(1, 2)
=> [2, 3]

a.values_at(1..2)
=> [2, 3]
```

#### first メソッド

- 配列の先頭の要素を返す
- 引数が指定されるとその数だけ配列で返す

```ruby
a = [1, 2, 3, 4, 5]

a.first
=> 1

a.first(1)
=> [1]

a.first(3)
=> [1, 2, 3]
```

#### last メソッド

- 配列の末尾の要素を返す
- 引数が指定されるとその数だけ配列で返す

```ruby
a = [1, 2, 3, 4, 5]

a.last
=> 5

a.last(1)
=> [5]

a.last(3)
=> [3, 4, 5]
```

#### assoc メソッド

- 配列の中の配列を検索し、その配列の最初の要素が指定された値と==で等しければその配列を返します
- 検索してくれるメソッドみたいな

```ruby
a = [[1, 'AAA'], [2, 'BBB'], [3, 'CCC'], [4, 'DDD']]

a.assoc('AAA')
=> nil

a.assoc(2)
=> [2, "BBB"]
```

#### rassoc メソッド

- 配列の中の配列を検索し、その配列のインデックスが1の要素が指定された値と==で等しければその配列を返します
- 検索してくれるメソッドみたいな

```ruby
a = [[1, 'AAA'], [2, 'BBB'], [3, 'CCC'], [4, 'DDD']]

a.rassoc(2)
=> nil

a.rassoc('BBB')
=> [2, "BBB"]
```

### 配列の要素を追加したり取り出したり

破壊的メソッド

| concat  | 1つ以上の | 配列を受け取り         | 配列の末尾            | に配列を連結                             |
| \<<     | 1つの     | オブジェクトを受け取り | 配列の末尾            | にオブジェクトを連結                     |
| push    | 1つ以上の | オブジェクトを受け取り | 配列の末尾            | にオブジェクトを連結                     |
| pop     |           |                        | 配列の末尾            | からオブジェクトを指定した数だけ取り出す |
| shift   |           |                        | 配列の頭              | からオブジェクトを指定した数だけ取り出す |
| unshift | 1つ以上の | オブジェクトを受け取り | 配列の頭              | にオブジェクトを連結                     |
| insert  | 1つの     | オブジェクトを受け取り | 第1引数で指定した場所 | にオブジェクトを挿入                     |

#### concat メソッド

配列の末尾に配列を破壊的に連結、引数はもちろん配列

```ruby
a = [1, 2, 3]
a.concat(4)
TypeError: no implicit conversion of Integer into Array

a = [1, 2, 3]
a.concat([4])
a
=> [1, 2, 3, 4]
```

#### \<< メソッド

配列の末尾にオブジェクトを破壊的に連結、引数は1つのみ

```ruby
a = [1, 2, 3]
a << 4
a
=> [1, 2, 3, 4]

a = [1, 2, 3]
a << [4]
a
=> [1, 2, 3, [4]]

a = [1, 2, 3]
a << 4, 5
SyntaxError: syntax error, unexpected ',', expecting end-of-input
```

#### push メソッド

配列の末尾にオブジェクトを破壊的に連結、引数は複数指定可能

```ruby
a = [1, 2, 3]
a.push(4)
a
=> [1, 2, 3, 4]

a = [1, 2, 3]
a.push([4])
a
=> [1, 2, 3, [4]]

a = [1, 2, 3]
a.push(*[4, 5]) # 配列の引数展開・・キモい
=> [1, 2, 3, 4, 5]

a = [1, 2, 3]
a.push(4, 5)
=> [1, 2, 3, 4, 5]
```

#### pop メソッド

配列の末尾から要素を破壊的に取り出す、引数にて取り出す個数を指定できる

```ruby
a = [1, 2, 3]
a.pop #=> 3
a
=> [1, 2]

a = [1, 2, 3]
a.pop(2) #=> [2, 3]
a
=> [1]

a = [1, 2, 3]
a.pop(3) #=> [1, 2, 3]
a
=> []

a = [1, 2, 3]
a.pop(4) #=> [1, 2, 3]
a
=> []

a = []
a.pop #=> nil
a
=> []
```

#### shift メソッド

配列の頭から要素を破壊的に取り出す、引数にて取り出す個数を指定できる

```ruby
a = [1, 2, 3]
a.shift #=> 1
a
=> [2, 3]

a = [1, 2, 3]
a.shift(2) #=> [1, 2]
a
=> [3]

a = [1, 2, 3]
a.shift(3) #=> [1, 2, 3]
a
=> []

a = [1, 2, 3]
a.shift(4) #=> [1, 2, 3]
a
=> []

a = []
a.shift #=> nil
a
=> []
```

#### unshift メソッド

配列の頭にオブジェクトを破壊的に連結、引数は複数指定可能

```ruby
a = [1, 2, 3]
a.unshift(4)
a
=> [4, 1, 2, 3]

a = [1, 2, 3]
a.unshift([4])
a
=> [[4], 1, 2, 3]

a = [1, 2, 3]
a.unshift(4, 5)
=> [4, 5, 1, 2, 3]
```

#### insert メソッド

指定した場所にオブジェクトを破壊的に挿入

```ruby
a = [1, 2, 3]
a.insert(1, 'a')
a
=> [1, "a", 2, 3]

a = [1, 2, 3]
a.insert(1, ['a', 'b'])
a
=> [1, ["a", "b"], 2, 3]
```

### 配列の要素を変更する

#### [] メソッド

配列の添字に2つ数値を指定、代入すると指定した長さの部分が代入したオブジェクトへ置き換わる

```ruby
as = [0, 1, 2, 3, 4]
as[1, 2] = '50'
as
=> [0, '50', 3, 4]
```

配列を渡すと元の配列より長くなったりも可能

```ruby
as = [0, 1, 2, 3, 4]
as[1, 2] = ['50', '51', '53']
as
=> [0, '50', '51', '53', 3, 4]

as = [0, 1, 2, 3, 4]
as[1, 2] = '60', '61', '63'
as
=> [0, "60", "61", "63", 3, 4]
```

単純な挿入みたいな動きにもできる

```ruby
as = [0, 1, 2, 3, 4]
as[1, 0] = ['71', '72']
as
=> [0, "71", "72", 1, 2, 3, 4]
```

空の配列を渡すと削除的な動きになる

```ruby
as = [0, 1, 2, 3, 4]
as[1, 2] = []
as
=> [0, 3, 4]
```

#### fill メソッド

配列の全ての要素が指定したオブジェクトを指すように変更する

```ruby
a = [1, 2, 3]
a.fill('z')

a
=> ["z", "z", "z"]

a[0].object_id
=> 70321654840300
a[1].object_id
=> 70321654840300
```

第2引数以降に始点終点、Rangeオブジェクトを指定すると当該する部分のみ変更される

```ruby
a = [1, 2, 3, 4, 5]
a.fill('z', 2, 2)

a
=> [1, 2, "z", "z", 5]
```

```ruby
a = [1, 2, 3, 4, 5]
a.fill('z', 1..3)

a
=> [1, "z", "z", "z", 5]
```

ブロックを取ることもでき、ブロックの評価結果で要素を変更する

```ruby
a = ['a', 'b', 'c', 'd', 'e']
a.fill(2..3) do |index|
  index + 100
end

a
=> ["a", "b", 102, 103, "e"]
```

#### replace メソッド

自分自身のオブジェクトIDを変えることなく、引数で指定された配列で自分自身の内容を置き換えます

```ruby
a = [1, 2, 3, 4, 5 ]
b = [6, 7, 8, 9, 10]

a
=> [1, 2, 3, 4, 5]

a.object_id
=> 70321654806640

a.replace(b)

a
=> [6, 7, 8, 9, 10]

a.object_id
=> 70321654806640
```

### イテレート （配列専用、という事ではないが、ここに書いておこう）

### for

forはスコープを作らないので、アクセスし放題

```ruby
moko = 1
for a in [1, 2, 3]
  p moko #=> 1
end
p moko #=> 1
for a in [1, 2, 3]
  moko = a
  homo = a
end
p moko #=> 3
p homo #=> 3
```

### each

スコープを作るので、内部で初期化したローカル変数は外には漏れ出さない

```ruby
moko = 1
[1, 2, 3].each do
  p moko #=> 1
end
p moko #=> 1
[1, 2, 3].each do |a|
  moko = a
  homo = a
end
p moko #=> 3
p homo
NameError: undefined local variable or method 'homo'
```
