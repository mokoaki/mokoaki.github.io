## リテラル

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### 数値リテラル

#### 指数表現

```ruby
> 5e1
=> 50.0 # 5 * 10の1乗

> 5.3e2
=> 530.0 # 5.3 * 10の2乗
```

#### 基数指示子

- 2進数 #=> 0b
- 8進数 #=> 0o か 0
- 10進数 #=> 0d
- 16進数 #=> 0x

小数とか、表現できない値を指定するとエラー

```ruby
# 2進数だぞ 11 #=> 3
0b11
=> 3

# 2進数だぞ 2 #=> エラー
0b2
SyntaxError: numeric literal without digits

# 8進数だぞ 11 #=> 9
0o11
=> 9

# 8進数だぞ 8 #=> エラー
0o8
SyntaxError: Invalid octal digit

# 10進数だぞ 11 #=> 11 (普通すぎる
0d11
=> 11

# 16進数だぞ 11 #=> 17
0x11
=> 17

# 16進数だぞ f #=> 15
0xf
=> 15

# 16進数だぞ g #=> エラー
0xg
SyntaxError: numeric literal without digits
```

#### _を使ってみやすく

```ruby
100_000
=> 100000
```

#### ?に続くリテラル

1.8の頃はこういう仕様だったらしい

```ruby
?R
=> 82
```

でもいつの間にか String表現を返す仕様になったらしい

使い所は謎

```ruby
?R
=> "R"

?\C-v
=> "\u0016" # CTRL+v を表すString・・・らしい

?\M-a
=> "\xE1" # META(ALT)+a を表すString・・・らしい

?\n
=> "\n"
```

### 有理数, 複素数リテラル

2.1から組み込みクラスとして使えるようになった

```ruby
42/10r #=> (21/5)
42r/10 #=> (21/5)
(42/10r).class #=> Rational
3.14r #=> (157/50)
'42/10'.to_r #=> (21/5)

42i #=> (0+42i)
42i.class #=> Complex
3.14i #=> (0+3.14i)
'0+42i'.to_c #=> (0+42i)

42ri #=> (0+(42/1)*i)
3.14ri #=> (0+(157/50)*i)
```

### 文字列リテラル

普通こんなことはしないけどできる マジかよ

```ruby
'ab' 'cd'
=> "abcd"

a = 10
b = "#{a}" 'mb'
=> "10mb"
b
=> "10mb"
```

#### 式展開

みんな知ってるね、ダブルクォーテーションと#{}で囲むといいんだよ

```ruby
"#{1 + 1}"
=> "2"
```

- 自動で to_s が呼び出される
- バックスラッシュ記法が使える

#### バックスラッシュ記法

| \\ | そのまんま\ |
| \n | 改行 |
| \r | キャリッジリターン |
| \f | 改ページ |
| \a | ベル |
| \e | エスケープ　( ｰ`дｰ´)？ |
| \s | 空白 |
| \b | バックスペース　( ｰ`дｰ´)？ |
| \t | タブ |
| \v | 垂直タブ　( ｰ`дｰ´)？ |
| \nnn | 8進数表記の文字 |
| \xnn | 16進数表記の文字 |
| \cx, \C-x | コントロールx |
| \M-x | メタx |
| \M-x | メタ コントロールx |
| \unnnn | unicord文字 |
| \u{nnnn nnnn} | unicord文字列 |

#### 先生、シングルクォートで囲んだ文字はバックスラッシュ記法は無視されるって事ですか？

シングルクォートのエスケープだけは有効なんだな、これが

```ruby
puts '\'\''
''
```

#### みんなチョット苦手、ヒアドキュメント

こんなの

```ruby
def sql_query
  <<SQL
    select *
    from mokos
SQL
end

sql_query
=> "    select *\n    from mokos\n"
```

なんかインデント変じゃね？と思ったあなたはエライ

ヒアドキュメントには、終端を示す文字列の前にはスペースなどの文字を記述してはいけない、というルールがある

```ruby
def sql_query
  <<SQL
    select *
    from mokos
  SQL
end

cant find string "SQL" anywhere before EOF
syntax error, unexpected end-of-input, expecting tSTRING_CONTENT or tSTRING_DBEG or tSTRING_DVAR or tSTRING_END
```

識別子の前にハイフンをつけると識別子がインデント出来るようになって使いやすくなる（ていうか、付けない表記はどういう時に使うんだろう？）

```ruby
def sql_query
  <<-SQL
    select *
    from mokos
  SQL
end

sql_query
=> "    select *\n    from mokos\n"
```

ヒアドキュメント内では式展開が有効

```ruby
<<HOMO
  #{1 + 1}
HOMO
=> "  2\n"
```

識別子をシングルクォートで囲むと式展開が無効になる

```ruby
<<'HOMO'
  #{1 + 1}
HOMO
=> "  \#{1 + 1}\n"
```

識別子をダブルクォートで囲むと、動作はデフォと変わらないが「式展開するぞ」と明示的に示す意味がある

```ruby
<<"HOMO"
  #{1 + 1}
HOMO
=> "  2\n"
```

#### パーセント記法

文字リテラルは基本的にシングルクォートかダブルクォートで囲む感じだけど、パーセント記法は好きな文字(英数字以外の適当な記号)で囲んで色々なリテラルを現せる

```ruby
%|fdas|
=> "fdas"

%[ ' " とか自由に使える ]
=> " ' \" とか自由に使える "
```

式展開が可能
```ruby
%*#{1 + 1}*
=> "2"
```

%qなら式展開がされない
```ruby
%q!#{1 + 1}!
=> "\#{1 + 1}"
```

%Qはデフォ(%だけ)と同じ動作を明示的に示す為に使ったりする
```ruby
%Q@#{1 + 1}@
=> "2"
```

パーセント記法で文字列を作ってきたけど、他にもいろいろ作れる

| %Q, % | ダブルクォート文字列（式展開あり）                           |
| %q    | シングルクォート文字列（式展開なし）                         |
| %W    | 空白文字を区切りとした配列（式展開あり）                     |
| %w    | 空白文字を区切りとした配列（式展開なし）                     |
|       | ↑大文字の方(Q, W)は式展開あり、小文字の方(q, w)は式展開なし |
| %s    | シンボル（式展開なし） ちなみに%Sは存在しない                |
| %x    | コマンド出力（！式展開あり！）                               |
| %r    | 正規表現（！式展開あり！）  e.g. %r(moko)i                   |

### コマンド出力

これもリテラルに分類するのか・・

```ruby
`pwd`
#=> "/Users/moko/not/hage\n"

# 終了ステータスも見れるよ
$?
=> #<Process::Status: pid 27637 exit 0>
```

```ruby
# 式展開もできるね
`#{'p' + 'w' + 'd'}`
# パーセント記法もおｋ
%x(pwd)
%x(#{'p' + 'w' + 'd'})
```
