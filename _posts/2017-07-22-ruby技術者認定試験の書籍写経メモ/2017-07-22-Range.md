## Range 範囲

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### Range#.. Range#...

- 1..10  #=> 1から10
- 1...10 #=> 1から10未満（右端の値は含まない）

```ruby
(1..5).to_a  #=> [1, 2, 3, 4, 5]
(1...5).to_a #=> [1, 2, 3, 4]

('a'..'e').to_a  #=> ["a", "b", "c", "d", "e"]
('a'...'e').to_a #=> ["a", "b", "c", "d"]
```

### 範囲オブジェクトの === は include? と同じ

ぶっちゃけ使わないけど、後述するcase式と相性が良いかも

```ruby
(1..5).include?(5)  #=> true
(1...5).include?(5) #=> false

(1..5) === 5  #=> true
(1...5) === 5 #=> false
```

### イテレータ

forはスコープを作らない、みんな知ってるね

```ruby
for i in 'a'..'e'
  p i
end
"a"
"b"
"c"
"d"
"e"
=> "a".."e"
```

```ruby
('a'..'e').each do |i|
  p i
end
"a"
"b"
"c"
"d"
"e"
=> "a".."e"
```

### 文字列、配列の添字演算子に範囲オブジェクトを使う

[開始場所、長さ] で指定の他に範囲でもイケる

```ruby
['a', 'b', 'c', 'd', 'e', 'f', 'g'][2, 4]  #=> ["c", "d", "e", "f"] # これは前にやった例、[2]から4つ
['a', 'b', 'c', 'd', 'e', 'f', 'g'][2..4]  #=> ["c", "d", "e"]      # [2]から[4]
['a', 'b', 'c', 'd', 'e', 'f', 'g'][2...4] #=> ["c", "d"]           # [2]から[4]未満（右端の値は含まない）
```

```ruby
'abcdefg'[2, 4]  #=> ["c", "d", "e", "f"] # これは前にやった例、[2]から4つ
'abcdefg'[2..4]  #=> ["c", "d", "e"]      # [2]から[4]
'abcdefg'[2...4] #=> ["c", "d"]           # [2]から[4]未満（右端の値は含まない）
```
