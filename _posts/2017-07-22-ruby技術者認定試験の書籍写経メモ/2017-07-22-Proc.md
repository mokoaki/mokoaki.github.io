## Proc

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### Proc

- ブロックを実行時のローカル変数などのコンテキストと共にオブジェクト化した手続きオブジェクトを扱うクラス
- 無名関数のように使うことができる
- ProcオブジェクトはProcクラスのコンストラクタにブロックを指定すると生成
- Procオブジェクトのcallメソッドを呼び出し実行する
- たとえば遅延評価、関数型プログラミングでも使う？

### RuboCop先生は手続きオブジェクトはこうやって作れって言ってくるんだよね、実際にはこう書いた方がいいんかね？

```ruby
# bad
p = Proc.new { |n| puts n }

# good
p = proc { |n| puts n }
```

### 手続きオブジェクトを生成、実行する

new して call

```ruby
proc = Proc.new { p 'hage-!' }
proc.call
#=> "hage-!"
```

### 手続きオブジェクトを生成、実行する　引数も取れる

```ruby
proc = Proc.new { |a| a + 1 }
proc.call(3)
#=> 4
```

生成された手続きオブジェクトの引数の数は、arityメソッドで取得できます

```ruby
proc = Proc.new { |a| a + 1 }

p proc.arity
=> 1
```

```ruby
proc = Proc.new { |a, b| a + b }

p proc.arity
=> 2
```

### オブジェクト生成時のコンテキストを保持しているため、ローカル変数の値などは実行時の状況に応じて変化する

procはaを参照できているのに(=>70)、hageメソッド内でaは参照することができない(NameError)

```ruby
a = 30
b = 40

proc = Proc.new { a + b }

def hage(proc)
  proc.call
  p a
end

hage(proc)
=> 70
=> NameError: undefined local variable or method 'a'
```

proc定義時に存在していない[a, b]への参照は出来ないっぽい。ホイストしてくれないって事でおｋ？

```ruby
p = Proc.new { a + b }

a = 30
b = 40

p.call
=> undefined local variable or method 'a'
```

procは[a, b]への参照を保持しているので、再実行時に[a, b]の値が変わっていても当然ながら値に追随して実行される

```ruby
a = 30
b = 40

proc = Proc.new { a + b }

proc.call
#=> 70

a = 50
b = 60

proc.call
#=> 110
```

### ブロック Proc 相互変換

- Procを渡す、ブロックとして受け取る
- &を付けて、最後の変数としてメソッドに渡すと、メソッドさんはそれをブロックとして扱ってくれる
- 逆に言うと、procオブジェクトへ参照は出来ない

```ruby
def moko(a)
  p block_given?
  a + yield
end

proc = Proc.new { 2 }

moko(1, &proc)
true
=> 3
```

- Procを渡す、Procとして受け取る
- &を付けて、最後の変数としてメソッドで受けると、メソッドさんはそれをprocとして扱ってくれる
- 呼び出し側にも&が必要っぽい？
- yieldもできるっぽい えマジで？

```ruby
def moko(a, &proc)
  p block_given?
  p yield
  a + proc.call
end

proc = Proc.new do
  p 'I am proc'
  2
end

moko(1, &proc)
true
"I am proc"
2
"I am proc"
=> 3
```

- ブロックを渡す、Procとして受け取る
- &を付けて、最後の変数としてメソッドで受けると、メソッドさんはそれをprocとして扱ってくれる
- yieldもできるっぽい えマジで？

```ruby
def moko(a, &proc)
  p block_given?
  p yield
  a + proc.call
end

moko(1) do
  p 'I am proc'
  2
end
true
"I am proc"
2
"I am proc"
=> 3
```

- つまり？
- どの例でもblock_given?はtrueだった
- どの例でもyieldが可能だった
- Procを渡す時には&を付ける
- Procとして受ける時には&を付ける　使う時には&は要らない
- 後でもっかい確認する
