## Proc

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### Proc

- ブロックをオブジェクト化したもの
- ProcオブジェクトはProcクラスのコンストラクタにブロックを指定すると生成
- Procオブジェクトのcallメソッドを呼び出し実行する
- どういう時に使うん？とりあえず先に処理生成だけして、後で遅延評価できる・・とかそんな・・感じで・・がんばって覚えて！

```ruby
proc = Proc.new { |a| a + 1 }
proc.call(3)
#=> 4

# クロージャへの参照をcallの瞬間までずっと保持しておいてくれる！と考えると使い所が見つかる？？
homo = 5
proc = Proc.new { |a| a + 1 + homo }
proc.call(3)
#=> 9
```

### ブロック Proc 相互変換

- Procを渡す、ブロックとして受け取る
- &を付けて、最後の変数としてメソッドに渡すと、メソッドさんはそれをブロックとして扱ってくれる
- 逆に言うと、procオブジェクトへ参照は出来ない

```ruby
def moko(a)
  p block_given?
  a + yield
end

proc = Proc.new { 2 }

moko(1, &proc)
true
=> 3
```

- Procを渡す、Procとして受け取る
- &を付けて、最後の変数としてメソッドで受けると、メソッドさんはそれをprocとして扱ってくれる
- 呼び出し側にも&が必要っぽい？
- yieldもできるっぽい えマジで？

```ruby
def moko(a, &proc)
  p block_given?
  p yield
  a + proc.call
end

proc = Proc.new do
  p 'I am proc'
  2
end

moko(1, &proc)
true
"I am proc"
2
"I am proc"
=> 3
```

- ブロックを渡す、Procとして受け取る
- &を付けて、最後の変数としてメソッドで受けると、メソッドさんはそれをprocとして扱ってくれる
- yieldもできるっぽい えマジで？

```ruby
def moko(a, &proc)
  p block_given?
  p yield
  a + proc.call
end

moko(1) do
  p 'I am proc'
  2
end
true
"I am proc"
2
"I am proc"
=> 3
```

- つまり？
- どの例でもblock_given?はtrueだった
- どの例でもyieldが可能だった
- Procを渡す時には&を付ける
- Procとして受ける時には&を付ける　使う時には&は要らない
- 後でもっかい確認する
