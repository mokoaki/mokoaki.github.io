## Proc

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### Proc

- ブロックを実行時のローカル変数などのコンテキストと共にオブジェクト化した手続きオブジェクトを扱うクラス
- 無名関数のように使うことができる
- ProcオブジェクトはProcクラスのコンストラクタにブロックを指定すると生成
- Procオブジェクトのcallメソッドを呼び出し実行する
- たとえば遅延評価、関数型プログラミングでも使う？

### RuboCop先生は手続きオブジェクトはこうやって作れって言ってくるんだよね、実際にはこう書いた方がいいんかね？

```ruby
# bad
p = Proc.new { |n| puts n }

# good
p = proc { |n| puts n }
```

### 手続きオブジェクトを生成、実行する

new して call

```ruby
proc = Proc.new { p 'hage-!' }
proc.call
#=> "hage-!"
```

### 手続きオブジェクトを生成、実行する　引数も取れる

```ruby
proc = Proc.new { |a| a + 1 }
proc.call(3)
#=> 4
```

生成された手続きオブジェクトの引数の数は、arityメソッドで取得できます

```ruby
proc = Proc.new { |a| a + 1 }

p proc.arity
=> 1
```

```ruby
proc = Proc.new { |a, b| a + b }

p proc.arity
=> 2
```

### オブジェクト生成時のコンテキストを保持しているため、ローカル変数の値などは実行時の状況に応じて変化する

procはaを参照できているのに(=>70)、hageメソッド内でaは参照することができない(NameError)

```ruby
a = 30
b = 40

proc = Proc.new { a + b }

def hage(proc)
  proc.call
  p a
end

hage(proc)
=> 70
=> NameError: undefined local variable or method 'a'
```

proc定義時に存在していない[a, b]への参照は出来ないっぽい。ホイストしてくれないって事でおｋ？

```ruby
p = Proc.new { a + b }

a = 30
b = 40

p.call
=> undefined local variable or method 'a'
```

procは[a, b]への参照を保持しているので、再実行時に[a, b]の値が変わっていても当然ながら値に追随して実行される

```ruby
a = 30
b = 40

proc = Proc.new { a + b }

proc.call
#=> 70

a = 50
b = 60

proc.call
#=> 110
```

### ブロック付きメソッドへの引数として利用する

- ブロック付きメソッドに手続きオブジェクトを渡すことも可能
- 変数名の前に&を付けて渡す

```ruby
proc = Proc.new { |i| p i }

3.times(&proc)
0
1
2
=> 3
```

```ruby
proc = Proc.new { |key, value| p "#{key}#{value}" }

{a: 1, b: 2, c: 3}.each(&proc)
"a1"
"b2"
"c3"
=> {:a=>1, :b=>2, :c=>3}
```

ただし、[後述](#後述) しますが break return next などのジャンプ構文で振る舞いが変わってくるので注意

### 手続きオブジェクトの中での処理の中断

手続きオブジェクトの中で処理を中断して呼び出し元へ値を戻すには breakでもreturnでもなく、nextを使用します

```ruby
proc = Proc.new do
  next
  p 'end'
end

proc.call
=> nil
```

```ruby
proc = Proc.new do
  next 'next' # 戻り値を指定
  p 'end'
end

proc.call
=> "next"
```

### メソッドへ手続きを渡す、メソッドで手続きを受け取る

| procオブジェクトを渡し、ブロックとして受け取る         |                                       |
| procオブジェクトを渡し、procオブジェクトとして受け取る |                                       |
| ブロックを渡し、procオブジェクトとして受け取る         |                                       |
| ブロックを渡し、ブロックとして受け取る                 | あ、これは平常時にyieldやってる奴だわ |

- メソッド呼び出し時の変数で、procオブジェクトに&を付けて呼び出すと「ブロックを渡すよ」という事になる。ブロックが渡されたのでyieldが可能になる。block_given?がtrueになる
- 呼び出されるメソッドで仮引数に&を付けた変数で受けとると「渡されたブロックをprocオブジェクトとして扱うよ」という事になる。ブロックが渡されたのでyieldが可能になる。block_given?がtrueになる

#### procオブジェクトを渡し、ブロックとして受け取る

- &を付けた最後の変数としてメソッドに渡すと、ブロックを渡した事になる
- 呼び出されたメソッドでは何の準備もしていないので普通にブロックをyieldで実行する事になる
- procオブジェクトへの参照は普通には出来なくなる
- ブロックが渡されたので block_given? は true

```ruby
def moko(a)
  p block_given?
  p a
  p yield
end

proc = Proc.new do
  'I am proc'
end

moko('hage', &proc)
true
"hage"
"I am proc"
```

#### procオブジェクトを渡し、procオブジェクトとして受け取る

- procオブジェクトを普通にオブジェクトのまま変数としてメソッドに渡す
- 呼び出されたメソッドでは何の準備もしていないので普通にcallで実行する事になる
- ブロックが渡されていないのでので yieldは出来ない。block_given? は false

```ruby
def moko(a, proc)
  p block_given?
  p a
  p proc.call
end

proc = Proc.new do
  'I am proc'
end

moko('hage', proc)
false
"hage"
"I am proc"
```

- &を付けた最後の変数としてメソッドに渡すと、ブロックを渡した事になる
- 呼び出されたメソッドでは最後の変数の頭に&を付けて、渡されたブロックをprocオブジェクトとして受け取る
- 受け取ったprocオブジェクトへのcallが可能
- ブロックが渡されたので yieldが可能。block_given? は true

```ruby
def moko(a, &proc)
  p block_given?
  p a
  p proc.call
  p yield
end

proc = Proc.new do
  'I am proc'
end

moko('hage', &proc)
true
"hage"
"I am proc"
"I am proc"
```

#### ブロックを渡し、procオブジェクトとして受け取る

- 呼び出されたメソッドでは最後の変数の頭に&を付けて、渡されたブロックをprocオブジェクトとして受け取る
- 受け取ったprocオブジェクトへのcallが可能
- ブロックが渡されたので yieldが可能。block_given? は true

```ruby
def moko(a, &proc)
  p block_given?
  p a
  p proc.call
  p yield
end

moko('hage') do
  'I am proc'
end
true
"hage"
"I am proc"
"I am proc"
```

#### ブロックを渡し、ブロックとして受け取る

- 特に新しい事はない
- ブロックをブロックのままメソッドに渡す
- ブロックが渡されたので yieldが可能。block_given? は true

```ruby
def moko(a)
  p block_given?
  p a
  p yield
end

moko('hage') do
  'I am proc'
end
true
"hage"
"I am proc"
```
