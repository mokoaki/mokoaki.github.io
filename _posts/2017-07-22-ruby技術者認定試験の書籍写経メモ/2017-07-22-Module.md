## Module クラス

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### 機能をひとまとめにした [モジュール]({% post_url 2017-07-22-クラス、オブジェクト指向、メソッド探索経路 %}#mix-in) の為のクラス

- 有用なメソッドが多数定義されている
- クラスのクラスであるClassクラスはこのModuleクラスを継承しているため、全てのクラスでこの有用なメソッドが利用できる

### モジュールを使った機能の追加

[Mix-in]({% post_url 2017-07-22-クラス、オブジェクト指向、メソッド探索経路 %}#mix-in) の辺りに書いてあります

### 定数に関するメソッド

| Module.constants        |
| レシーバ.constants      |
| レシーバ.const_defined? |
| レシーバ.const_get      |
| レシーバ.const_set      |
| レシーバ.remove_const   |
| レシーバ.ancestors      |
| レシーバ.const_missing  |

#### Module.constants メソッド

その時点で定義されている定数一覧を取得する

```ruby
Module.constants
=> [:Integer, :Float] # 大量の配列
```

#### constants メソッド

特定のクラスやモジュールで定義されている定数の一覧を取得する

```ruby
Regexp.constants
=> [:IGNORECASE, :EXTENDED, :MULTILINE, :FIXEDENCODING, :NOENCODING]
```

#### const_defined? メソッド

特定のクラスやモジュールで、指定した定数が定義されているかどうか

```ruby
Regexp.const_defined?(:IGNORECASE)
=> true

Regexp.const_defined?(:HAGE)
=> false
```

#### const_get メソッド

特定のクラスやモジュールの定数の値を取り出す

```ruby
Regexp.const_get(:IGNORECASE)
=> 1

Regexp::IGNORECASE
=> 1
```

#### const_set メソッド

特定のクラスやモジュールの定数の値を設定する

```ruby
Regexp.const_get(:HAGE)
=> NameError: uninitialized constant Regexp::HAGE

Regexp::HAGE
=> NameError: uninitialized constant Regexp::HAGE

Regexp.const_set(:HAGE, true)

Regexp.const_get(:HAGE)
=> true

Regexp::HAGE
=> true
```

#### remove_const メソッド

- 特定のクラスやモジュールの定数を取り除く
- privateメソッド

クラスメソッドから自らの定数を消させる

```ruby
class Moko
  HAGE = true

  class << self
    def remove
      remove_const(:HAGE)
    end
  end
end

Moko.const_get(:HAGE)
=> true

Moko::HAGE
=> true

Moko.remove
=> true

Moko.const_get(:HAGE)
=> NameError: uninitialized constant Moko::HAGE

Moko::HAGE
=> NameError: uninitialized constant Moko::HAGE
```

sendメソッドから無理やり定数を消す

```ruby
class Moko
  HAGE = true
end

Moko.const_get(:HAGE)
=> true

Moko::HAGE
=> true

Moko.send(:remove_const, :HAGE)
=> true

Moko.const_get(:HAGE)
=> NameError: uninitialized constant Moko::HAGE

Moko::HAGE
=> NameError: uninitialized constant Moko::HAGE
```

#### ancestors メソッド

- 継承チェーンを配列で返す
- 特異クラスは配列に含まれない
- includeしたモジュールも配列に含まれる
- extendしたモジュール（特異クラス）は配列に含まれない
- \[自分, 自分#included_module, 親, 親#included_module, Object, Kernel, BasicObject\] のような配列となる

```ruby
module OyajiModule1
end

module OyajiModule2
end

module MokoModule1
end

module MokoModule2
end

class Oyaji
  include OyajiModule1
  extend  OyajiModule2

  class << self
  end
end

class Moko < Oyaji
  include MokoModule1
  extend  MokoModule2

  class << self
  end
end

Moko.ancestors
=> [Moko, MokoModule1, Oyaji, OyajiModule1, Object, Kernel, BasicObject]
```

#### const_missing メソッド

- 継承チェーンを駆け上った末のBasicObjectでも定数が見つからない場合、呼び出し元のオブジェクトの#const_missingが呼び出される
- この#const_missingも継承チェーンを駆け上り、BasicObject#const_missingまで到達すると例外NameErrorが発生する
- 各クラスのconst_missingメソッドをオーバーライドする事で、継承チェーン全てをチェックしてもメソッドが見つからない場合の動作をフックすることができる

```ruby
class Moko
  class << self
    def const_missing(const_name)
      p const_name
      return 'hage-!'
    end
  end
end

Moko::Hoge
:Hoge
=> "hage-!"
```

### メソッドを設定する

#### インスタンスメソッドの一覧を取得

| instance_methods           |
| public_instance_methods    |
| protected_instance_methods |
| private_instance_methods   |

[オブジェクトが持つインスタンスメソッドインスタンス変数]({% post_url 2017-07-22-クラス、オブジェクト指向、メソッド探索経路 %}#オブジェクトが持つインスタンスメソッドインスタンス変数を確認する)

#### メソッドの可視性の変更

| public    |
| protected |
| private   |

[メソッドの可視性]({% post_url 2017-07-22-クラス、オブジェクト指向、メソッド探索経路 %}#メソッドの可視性)

#### アクセッサメソッド

| attr_reader  |
| attr_writer  |
| attr_ccessor |
| attr         |

[アクセッサメソッド]({% post_url 2017-07-22-クラス、オブジェクト指向、メソッド探索経路 %}#アクセッサメソッドの生成を行うメソッド)

#### メソッドの別名を定義する

| alias_methods |

- [メソッドに別名を付ける]({% post_url 2017-07-22-クラス、オブジェクト指向、メソッド探索経路 %}#メソッドに別名を付ける)
- alias との違いは、aliasは予約語であり直接メソッドを指定できるのに対し、alias_methodsメソッドでありメソッド名を文字列で指定できる事

正直、その違いだけならどっちでもいいや！と思う

```ruby
class Moko1
  def zura
    p true
  end

  alias hage zura
  # alias :hage :zura #これでもいい
end

Moko1.new.hage
=> true
```

```ruby
class Moko2
  def zura
    p true
  end

  alias_method :hage, :zura
  # alias_method 'hage', 'zura' # これでもいい
end

Moko2.new.hage
=> true
```

こんな風に使うんかねー？

```ruby
class Oyaji
  def method1
    'oyaji'
  end
end

class Moko < Oyaji
  alias_method :original_method, :method1

  def method1
    'moko ' + original_method
  end
end

Moko.new.method1
=> "moko oyaji"
```

### 評価する

| eval          | 現在のコンテキストで評価します                 |
| module_eval   | 指定したモジュールのコンテキストで評価します   |
| class_eval    | 指定したクラスのコンテキストで評価します       |
| instance_eval | 指定したオブジェクトのコンテキストで評価します |

**module_evalメソッドはclass_evalの別名です**

#### 文字列をRubyコードとして評価する

```ruby
eval('Regexp')
=> Regexp
end
```

```ruby
Regexp.class_eval('IGNORECASE')
=> 1
```

```ruby
a = /moko/i

a.instance_eval('inspect')
=> "/moko/i"
```

#### ブロックをクラス定義やモジュール定義の中のコードであるように実行する

例えばこの例はインスタンスメソッドになる

```ruby
//.hage
=> NoMethodError: undefined method 'hage'

Regexp.class_eval do
  def hage
    'hage-!'
  end
end

//.hage
=> "hage-!"
```

例えばこの例は特異メソッドになる

```ruby
a = //

a.instance_eval do
  def hage
    'hage-!'
  end
end

a.hage
=> "hage-!"

//.hage
=> NoMethodError: undefined method 'hage' for //:Regexp
```

### 引数を渡して評価したい

| module_exec   | 指定したモジュールのコンテキストで評価します   |
| class_exec    | 指定したクラスのコンテキストで評価します       |
| instance_exec | 指定したオブジェクトのコンテキストで評価します |

**module_execメソッドはclass_execの別名です**

#### ブロックをクラス定義やモジュール定義の中のコードであるように実行する with 引数

こんな使い方はしないと思います、無理矢理な例でスンマセン

```ruby
//.hage
=> NoMethodError: undefined method 'hage'

Regexp.class_exec(10) do |num|
  @@test = num

  def hage
    "hage#{@@test}"
  end
end

//.hage
=> "hage10"
```

```ruby
a = //

a.instance_exec(10) do |num|
  @test = num

  def hage
    "hage#{@test}"
  end
end

a.hage
=> "hage10"

//.hage
=> NoMethodError: undefined method 'hage' for //:Regexp
```

### クラス変数を扱う

| class_variables         |
| class_variable_defined? |
| class_variable_get      |
| class_variable_set      |
| remove_class_variable   |

#### class_variables メソッド

クラス変数の一覧を取得

```ruby
class Moko
  @@homo = true
  @@hage = true
end

Moko.class_variables
=> [:@@homo, :@@hage]
```

#### class_variable_defined? メソッド

指定されたクラス変数が定義されているかどうか

```ruby
class Moko
  @@homo = true
  @@hage = true
end

Moko.class_variable_defined?(:@@homo)
=> true

Moko.class_variable_defined?(:@@test)
=> false
```

#### class_variable_get メソッド

指定されたクラス変数を取得

```ruby
class Moko
  @@homo = true
  @@hage = true
end

Moko.class_variable_get(:@@homo)
=> true

Moko.class_variable_get(:@@test)
=> NameError: uninitialized class variable @@test in Moko
```

#### class_variable_set メソッド

指定されたクラス変数を設定

```ruby
class Moko
  @@homo = true
  @@hage = true
end

Moko.class_variable_get(:@@test)
=> NameError: uninitialized class variable @@test in Moko

Moko.class_variable_set(:@@test, true)

Moko.class_variable_get(:@@test)
=> true

Moko.class_variables
=> [:@@homo, :@@hage, :@@test]
```

#### remove_class_variable メソッド

指定されたクラス変数を取り除く

```ruby
class Moko
  @@homo = true
  @@hage = true
end

Moko.class_variables
=> [:@@hage, :@@homo]

Moko.remove_class_variable(:@@homo)

Moko.class_variables
=> [:@@hage]
```

### モジュールの機能を取り込む

| include         |
| extend          |
| included        |
| extended        |
| include?        |
| include_modules |
| autoload        |
| autoload?       |









a
