## 正規表現 Regexp

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

### 正規表現オブジェクトを生成する

| 正規表現リテラル       | /moko/             |                        |
| 正規表現クラスメソッド | Regexp.new('moko') | Regexp.compile('moko') |
| パーセント表記         | %r(moko)           |                        |

#### 正規表現リテラル

#### 正規表現リテラルのオプション

| i | 大文字小文字の無視                                |
| m | マルチラインモード . が改行にマッチするようになる |
| x | 空白やコメントを無視                              |

i 大文字小文字の無視

```ruby
/moko/ === 'MOKO'
=> false

/moko/i === 'MOKO'
=> true
```

m 大文字小文字の無視

```ruby
/\Aa.*a\z/ === "a\na"
=> false

/\Aa.*a\z/m === "a\na"
=> true
```

x 空白やコメントの無視

```ruby
/\da\da\d/ === '0a0a0'
=> true

/\d a \d a \d/x === '0a0a0'
=> true

/
 \d # 0-9
 a  # a
 \d # 0-9
 a  # a
 \d # 0-9
/x ===  '0a0a0'
=> true
```

#### 正規表現クラスメソッド

```ruby
Regexp.new('moko')
```

#### 正規表現クラスメソッドのオプション

| Regexp::IGNORECASE | 大文字小文字の無視                                |
| Regexp::MULTILINE  | マルチラインモード . が改行にマッチするようになる |
| Regexp::EXTENDED   | 空白やコメントを無視                              |

```ruby
Regexp.new('moko', Regexp::IGNORECASE)
=> /moko/i

Regexp.new('moko', Regexp::MULTILINE)
=> /moko/m

Regexp.new('moko', Regexp::EXTENDED)
=> /moko/x
```

論理和によって複数指定も可能

```ruby
Regexp.new('moko', Regexp::IGNORECASE | Regexp::MULTILINE)
=> /moko/mi
```

「マッチングする時の文字コードを第3引数で指定することも出来ます」らしいのだが、ぐぐっても良く判らなかった・・

#### パーセント表記

```ruby
%r(moko)
=> /moko/
```

TODO オプションはどうする？

### 正規表現オブジェクトでマッチングする

#### regexp#match メソッド

- マッチした場合は MatchDataオブジェクトが生成される
- マッチしなかった場合は nil

```ruby
/moko/.match('moko')
=> #<MatchData "moko">

/moko/.match('hage')
=> nil
```

#### regexp#=~ メソッド

- マッチした場合は マッチ箇所のインデックスを返す
- マッチしなかった場合は nil

```ruby
/moko/ =~ 'moko'
=> 0

/moko/ =~ 'hage'
=> nil
```

また、string#=~ も同じ動作をする

```ruby
'moko' =~ /moko/
=> 0

'moko' =~ /hage/
=> nil
```

#### regexp#=== メソッド

- マッチした場合は true
- マッチしなかった場合は false

```ruby
/moko/ === 'moko'
=> true

/moko/ === 'hage'
=> false
```

### 謎の ~ メソッド

- ~ メソッドは $_ とマッチングするメソッドである
- マッチした場合は マッチ箇所のインデックスを返す
- マッチしなかった場合は nil

```ruby
$_ = 'moko'

~ /moko/
=> 0

~ /hage/
=> nil
```

### 正規表現の特殊文字をエスケープする

正規表現ではピリオド[.]やカッコ等でマッチングする場合、これらの文字をエスケープする必要がある。これらのエスケープを自動的に行うのが下記のメソッドである

| Regexp.escape |
| Regexp.quote  |

```ruby
Regexp.escape('hash[:hage]')
=> "hash\\[:hage\\]"

Regexp.escape('hash[:hage]').class
=> String

Regexp.new(Regexp.escape('hash[:hage]')) === 'hash[:hage]'
=> true
```

エスケープを行うというよりは、エスケープ済みの文字列を生成する、といった感じか

### マッチした結果を取得する

最後に行った正規表現のマッチ結果は下記に保存されている

| Regexp.last_match |
| $~                |

```ruby
/moko/ === 'moko'
=> true

Regexp.last_match
=> #<MatchData "moko">

$~
=> #<MatchData "moko">
```

#### Regexp.last_match に整数を与えるとマッチ結果が得られる

| Regexp.last_match(0) | マッチした箇所  |
| Regexp.last_match(1) | マッチした箇所  |
| Regexp.last_match(2) | キャプチャ箇所2 |
| Regexp.last_match(3) | キャプチャ箇所3 |

```ruby
/(\d+)b(\d+)c(\d+)/ === 'a123b456c789d'
=> true

Regexp.last_match(0)
=> "123b456c789"

Regexp.last_match(1)
=> "123"

Regexp.last_match(2)
=> "456"

Regexp.last_match(3)
=> "789"
```

特殊変数でもアクセスできる

| $& | マッチした箇所  |
| $1 | マッチした箇所  |
| $2 | キャプチャ箇所2 |
| $3 | キャプチャ箇所3 |

```ruby
/(\d+)b(\d+)c(\d+)/ === 'a123b456c789d'
=> true

$&
=> "123b456c789"

$1
=> "123"

$2
=> "456"

$3
=> "789"
```


==============================



### Ruby版 正規表現記号まとめ

- Javascriptのはココにまとめたんだけど・・またやるか
- https://gist.github.com/mokoaki/9a64b36f32ca42c80d4c1d76b26e987e

| .     | 改行を除く任意の1文字（ただしmオプションを指定した時には改行もマッチ） |
| \d    | [0-9]                                                                  |
| \D    | \d以外                                                                 |
| \w    | [a-z][A-Z][0-9]                                                        |
| \W    | \w以外                                                                 |
| \s    | 空白文字、\t, \n, \r, \f 等                                            |
| \S    | \s以外                                                                 |
| \A    | データ先頭                                                             |
| \z    | データ末尾                                                             |
| \Z    | データ末尾が改行で終わっていればその直前                               |
| *     | 0回以上の繰り返し                                                      |
| +     | 1回以上の繰り返し                                                      |
| {m}   | m回の繰り返し                                                          |
| {m,}  | 最低m回の繰り返し                                                      |
| {m,n} | 最低m回、最高n回の繰り返し                                             |
| ()    | グループ化、キャプチャ（後方参照）                                     |
| //i   | 大文字小文字の区別をしない                                             |
| //o   | 一度だけ式展開を行う                                                   |
| //x   | パターン中の空白と改行を無視、＃以降はコメントとして無視               |
| //m   | マルチラインモード                                                     |

### 正規表現の特殊変数覚えてる？

- 特殊変数の一覧は上の方に書いてあるんで
- あれ？組み込み変数って言ってる人もいる・・どっちやねん
- 特に `&' の3つは英字キーボードでもこんな感じの並びなので覚えやすいか？？

```ruby
/bb/ === 'aabbcc'
$` #=> "aa" # マッチ箇所より前
$& #=> "bb" # マッチ箇所
$' #=> "cc" # マッチ箇所より後
```

```ruby
# キャプチャ後方参照もいじってみる
/(a|b)1.*(?:c|d)1.*(e|f)1/ === 'ab1 c1d e1f'
$+ #=> "e"
$1 #=> "b"
$2 #=> "e"
$3 #=> nil
```

```ruby
# オプションもちょっといじってみる
/moko/  === 'I AM MOKO.' #=> false
/moko/i === 'I AM MOKO.' #=> true

/a.*b/  === "a \n b" #=> false
/a.*b/m === "a \n b" #=> true
```
