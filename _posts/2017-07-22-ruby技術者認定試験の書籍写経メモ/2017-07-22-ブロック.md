## ブロック

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

- それはクロージャ
- ブロックはメソッド呼び出し時のみ記述が可能
- ブロックはスコープを作る

```ruby
def moko(a)
  a + yield
end

moko(1) do
  2 + 3
end
=> 6

moko(1) { 2 * 3 }
=> 7
```

```ruby
# スコープを作る、とは？
# その正体は？クロージャ？
hage1 = 1

def moko
  yield
end

moko do
  hage1 = 100
  hage2 = 100
end

hage1
=> 100
hage2
NameError: undefined local variable or method 'hage2'
```

### ここ、重要そうな事が書いてあるぞ！

- (メソッド定義 && ブロック定義)外で定義されたhage1は、(メソッド定義 && ブロック定義)外から（当然）参照できる
- (メソッド定義 && ブロック定義)外で定義されたhage1は、ブロック定義内から参照できる。ブロックが生成された時の周りの変数等はクロージャに含められる（束縛される）
- ブロック定義中で定義されたhage2は、外側から参照できない。ていうかブロックと共に消滅する
- 上の例には書いていないが、メソッド定義外で定義されたhage1は、メソッド定義内から参照できない。ローカル変数の存在境界の1つはメソッド定義だから（このあたりややこしいよね）
- クロージャ、それは処理（ブロック）生成時の環境を束縛（環境への参照を保持）するもの
- Rubyではメソッド内から外部の変数は参照できないが、これを逆手に取れば呼び出し元の変数を処理に持ち込む数少ない手段ともなる

### ブロックは引数を受け取れる

```ruby
def moko(num)
  yield(num, 2)
end

moko(1) do |a, b|
  a + b
end
=> 3
```

### メソッド内でブロックが指定されたかどうか判定

```ruby
def moko(num)
  return 'block...' if block_given? == false
  yield(num, 2)
end

moko(1)
=> "block..."

moko(1) do |a, b|
  a + b
end
=> 3

```

### Proc

- ブロックをオブジェクト化したもの
- ProcオブジェクトはProcクラスのコンストラクタにブロックを指定すると生成
- Procオブジェクトのcallメソッドを呼び出し実行する
- どういう時に使うん？とりあえず先に処理生成だけして、後で遅延評価できる・・とかそんな・・感じで・・がんばって覚えて！

```ruby
proc = Proc.new { |a| a + 1 }
proc.call(3)
#=> 4

# クロージャへの参照をcallの瞬間までずっと保持しておいてくれる！と考えると使い所が見つかる？？
homo = 5
proc = Proc.new { |a| a + 1 + homo }
proc.call(3)
#=> 9
```

### ブロック Proc 相互変換

- Procを渡す、ブロックとして受け取る
- &を付けて、最後の変数としてメソッドに渡すと、メソッドさんはそれをブロックとして扱ってくれる
- 逆に言うと、procオブジェクトへ参照は出来ない

```ruby
def moko(a)
  p block_given?
  a + yield
end

proc = Proc.new { 2 }

moko(1, &proc)
true
=> 3
```

- Procを渡す、Procとして受け取る
- &を付けて、最後の変数としてメソッドで受けると、メソッドさんはそれをprocとして扱ってくれる
- 呼び出し側にも&が必要っぽい？
- yieldもできるっぽい えマジで？

```ruby
def moko(a, &proc)
  p block_given?
  p yield
  a + proc.call
end

proc = Proc.new do
  p 'I am proc'
  2
end

moko(1, &proc)
true
"I am proc"
2
"I am proc"
=> 3
```

- ブロックを渡す、Procとして受け取る
- &を付けて、最後の変数としてメソッドで受けると、メソッドさんはそれをprocとして扱ってくれる
- yieldもできるっぽい えマジで？

```ruby
def moko(a, &proc)
  p block_given?
  p yield
  a + proc.call
end

moko(1) do
  p 'I am proc'
  2
end
true
"I am proc"
2
"I am proc"
=> 3
```

- つまり？
- どの例でもblock_given?はtrueだった
- どの例でもyieldが可能だった
- Procを渡す時には&を付ける
- Procとして受ける時には&を付ける　使う時には&は要らない
- 後でもっかい確認する

### lambda

- らむだ
- Procインスタンスを生成するがちょっと振る舞いが違う
- lambdaはメソッドぽい動き
- Proc(lambda)内でreturnした時に、lambdaはcallした行へ戻る（メソッドっぽい）、Proc(ブロック)はcallした所（生成元のスコープ）から脱出する
- 呼び出された時に、lambdaは引数の数を厳格に確認する（メソッドっぽい）、Proc(ブロック)は適当に無視するかnilで埋めてくれる

まずは普通にcallする、Procと特に違いは無いように見える

```ruby
lmd = lambda { |a| p a }

# 1.9からの新記法
lmd = -> (a) { p a }

lmd.call(1)
1
=> 1
```

return時の振る舞いがProcと違う

```ruby
# Proc
def moko
  proc = Proc.new do
    return 1
  end

  proc.call # returnで現在のスコープを脱出する　この行にreturnが書いていたかのような動作
  2         # この行は実行されない
end

moko
#=> 1

# lambda
def moko
  lmd = -> do
    return 1
  end

  lmd.call # returnで脱出するのはProc(lambda)内の処理だけ
  2        # この行は実行される
end

moko
#=> 2
```

当然ながら、トップレベルでProc { return }すると戻り先が無いのでエラー

```ruby
Proc.new { return }.call
LocalJumpError: unexpected return

# うう・・この動作はどう説明すればいい・・
def moko
  yield
end

moko do
  return
end
LocalJumpError: unexpected return
```

呼び出し時の引数の数が一致しない時の挙動が違う

```ruby
# Proc
proc = Proc.new { |a| a }
proc.call(1, 2) # 引数の数が多い
=> 1            # 2つめの引数は無視してくれる
proc.call       # 引数の数が少ない
=> nil          # とりあえずnilで処理を継続してくれる

# ブロック1
def moko
  yield(1, 2) # 引数の数が多い
end

moko do |a|
  a
end
=> 1 # 2つめの引数は無視してくれる

# ブロック2
def moko
  yield # 引数の数が少ない
end

moko do |a|
  a
end
=> nil # とりあえずnilで処理を継続してくれる

# lambda
lmd = -> (a) { a }
lmd.call(1, 2) # 引数の数が多い
ArgumentError: wrong number of arguments (given 2, expected 1) # 見逃してくれない
lmd.call       # 引数の数が少ない
ArgumentError: wrong number of arguments (given 0, expected 1) # 見逃してくれない
```

### ブロックを受け取る色々なメソッド

ぶっちゃけ基本的なものばかりだけどまぁ確認用に

```ruby
[1, 2, 3].each do |value|
  p value
end

[1, 2, 3].each_with_index do |value, index|
  p [value, index]
end
[1, 0]
[2, 1]
[3, 2]

[1, 2, 3].each.with_index(100) do |value, index|
  p [value, index]
end
[1, 100]
[2, 101]
[3, 102]

{a: 1, b: 2}.each do |key, value|
  p [key, value]
end
[:a, 1]
[:b, 2]

{a: 1, b: 2}.each_with_index do |(key, value), index|
  p [key, value, index]
end
[:a, 1, 0]
[:b, 2, 1]

{a: 1, b: 2}.each.with_index(100) do |(key, value), index|
  p [key, value, index]
end
[:a, 1, 100]
[:b, 2, 101]

{a: 1, b: 2}.each_key do |key|
  p key
end
:a
:b

{a: 1, b: 2}.each_value do |key|
  p key
end
1
2

('a'..'c').each do |value|
  p value
end
"a"
"b"
"c"

1.upto(3) do |value|
  p value
end
1
2
3

3.downto(1) do |value|
  p value
end
3
2
1

3.times do
  p 'homo'
end
"homo"
"homo"
"homo"
```
