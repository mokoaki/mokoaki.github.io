## 文字列 String

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

1.9よりStringオブジェクトはエンコーディング情報を保持するようになった。この為、Stringオブジェクトのメソッドは1文字を単位として動くように変わった

#### 主な文字コード

| UTF-8       | 主に使用されている文字コード                                                  |
| EUC-JP      | 古いUNIXシステムで利用されていたコード                                        |
| JIS         | JISで策定された7bit文字のみを使った文字コード                                 |
| Shift_JIS   | マルチバイト文字とASCII文字を切り替えることなく使用できるようにした文字コード |
| Windows-31J | 主にWindowsで使われていたShift-JISの亜種                                      |
| US-ASCII    | ASCII文字だけで構成されている文字コード                                       |

### 文字列のエンコーディングの取得

String#encodingメソッドはEncodingクラスのインスタンスを返す

```ruby
'aaa'.encoding
=> #<Encoding:UTF-8>
```

### 文字列のエンコーディングの変更

String#encode String#Encode!

```ruby
'aaa'.encode('EUC-JP').encoding
=> #<Encoding:EUC-JP>
```

### 文字列の比較

| ==      | そ                            |
| >       | の                            |
| >=      | ま                            |
| <       | ん                            |
| <=      | ま                            |
| <=>     | 件のUFO演算子 左が大きければ1 |
| casecmp | 文字の大小を無視してUFO演算子 |

### 文字列と異なるクラスのオブジェクトの比較

== メソッドのみ、異なるクラスのオブジェクトと比較できるが、型の自動変換は行われないので結果はfalseとなる

```ruby
'100' == 100
=> false

'100' >= 100
ArgumentError: comparison of String with 100 failed
```

### 文字列の比較時のエンコーディング

- 文字列の比較のときにもエンコーディングを意識する必要がある
- == eql? メソッドは両者が同じエンコーディングでなければfalseを返す。ただし、ASCII文字しか含んでいない場合にはtrueを返す

```ruby
'もこ' == 'もこ'
=> true

'もこ' == 'もこ'.encode('EUC-JP')
=> false

'ABC' == 'ABC'.encode('EUC-JP')
=> true
```

### 文字列の分割

split メソッドは文字列や正規表現にて文字列を分割する

```ruby
'abcde'.split('c')
=> ["ab", "de"]

'abcde'.split(/c/)
=> ["ab", "de"]
```

### 文字列の切り出し

- [] slice slice! メソッドに数値を渡し、場所を指定して文字列を切り出す
- slice!は元の文字列から破壊的に切り出す

```ruby
'abcde'[2]
=> "c"

'abcde'.slice(2)
=> "c"

'abcde'[-2]
=> "d"

'abcde'.slice(-2)
=> "d"

a = 'abcde'

a.slice!(2)
=> "c"

a
=> "abde"
```

範囲オブジェクトを渡すと該当する範囲が対象になる

```ruby
'abcde'[1..3]
=> "bcd"

'abcde'.slice(1..3)
=> "bcd"

a = 'abcde'

a.slice!(1..3)
=> "bcd"

a
=> "ae"
```

- 範囲の指定は範囲オブジェクトだけではなく、開始位置、長さ　で渡すこともでき
- 特に開始位置はマイナスを渡すと末尾から数えた数になる、といういつものあの動きをする
- 文字列よりも長い長さが渡されても可能な部分だけ返してくれる

```ruby
'abcde'[1, 3]
=> "bcd"

'abcde'.slice(1, 3)
=> "bcd"

a = 'abcde'

a.slice!(1, 3)
=> "bcd"

a
=> "ae"
```

- 文字列で指定すると元の文字列に含まれていればその部分を、含まれていなければnilを返す
- 最初に一致した箇所だけが対象
- ぶっちゃけ使わない

```ruby
'abcdeabcde'['bc']
=> "bc"

'abcdeabcde'.slice('bc')
=> "bc"

a = 'abcdeabcde'

a.slice!('bc')
=> "bc"

a
=> "adeabcde"
```

- 正規表現でも指定できるらしい
- 最初に一致した箇所だけが対象
- ぶっちゃけ使わない

```ruby
'abcdeabcde'[/bc/]
=> "bc"

'abcdeabcde'.slice(/bc/)
=> "bc"

a = 'abcdeabcde'

a.slice!(/bc/)
=> "bc"

a
=> "adeabcde"
```

### 文字列の変更

- 文字列の一部分を変更することができる
- []= メソッドには前項でやったような色々な指定方法が使える
- insert メソッドもあるよ たぶん使わないけど

```ruby
a = 'abcdeabcde'
a[3] = '_hage_'
a
=> "abc_hage_eabcde"

a = 'abcdeabcde'
a[3, 2] = '_hage_'
a
=> "abc_hage_abcde"

a = 'abcdeabcde'
a[3..4] = '_hage_'
a
=> "abc_hage_abcde"

a = 'abcdeabcde'
a['bc'] = '_hage_'
a
=> "a_hage_deabcde"

a = 'abcdeabcde'
a[/bc/] = '_hage_'
a
=> "a_hage_deabcde"
```

```ruby
a = 'abcdeabcde'
a.insert(3, '_hage_')
a
=> "abc_hage_deabcde"
```

### 文字列の一部を置換

| sub      | sub!     |
| gsub     | gsub!    |
| tr       | tr!      |
| tr_s     | tr_s!    |
| delete   | delete!  |
| squeeze  | squeeze! |
| replace  | 　       |

- それぞれ置換した文字列を返すが、!が付いているメソッドは元の文字列を破壊的に変更する
- replaceメソッドはそれ自体が破壊的なので!は付いていない

#### sub sub!

指定したパターンに最初にマッチした箇所を指定した文字列に変更する

```ruby
'abcabc'.sub('bc', '_hage_')
=> "a_hage_abc"

'abcabc'.sub(/bc/, '_hage_')
=> "a_hage_abc"

a = 'abcabc'
a.sub!('bc', '_hage_')
a
=> "a_hage_abc"
```

#### gsub gsub!

指定したパターンにマッチした箇所を全て指定した文字列に変更する

```ruby
'abcabc'.gsub('bc', '_hage_')
=> "a_hage_a_hage_"

'abcabc'.gsub(/bc/, '_hage_')
=> "a_hage_a_hage_"

a = 'abcabc'
a.gsub!('bc', '_hage_')
a
=> "a_hage_a_hage_"
```

また、ブロックを取ることもでき、実行結果へと置換される

```ruby
'abcabc'.sub('bc') do |match_data|
  "_#{match_data}_"
end
=> "a_bc_abc"
```

```ruby
'1_2_3'.gsub(/\d/) do |match_data|
  match_data.to_i + 5
end
=> "6_7_8"
```

#### tr tr! tr_s tr_s!

- tr は指定したパターンに含まれる文字を検索し、それを特定の文字列やパターンに併せて置換する
- tr_s はそれに加え、重複する文字を1文字に圧縮する

```ruby
'aabbccddee'.tr('b-d', 'B-D')
=> "aaBBCCDDee"

'aabbccddee'.tr('b-d', 'L-N')
=> "aaLLMMNNee"

'aabbccddee'.tr('b-e', 'B-D')
=> "aaBBCCDDDD"
```

```ruby
'aabbccddee'.tr_s('b-d', 'B-D')
=> "aaBCDee"

'aabbccddee'.tr_s('b-d', 'L-N')
=> "aaLMNee"

'aabbccddee'.tr_s('b-e', 'B-D')
=> "aaBCD"
```

#### delete delete!

- 指定したパターンに含まれる文字を検索し削除する
- 複数のパターンを指定すると全てのパターンに含まれる文字列のみ削除する

```ruby
'aabbccddee'.delete('b')
=> "aaccddee"

'aabbccddee'.delete('a-c')
=> "ddee"

'aabbccddee'.delete('a-c', 'b-d')
=> "aaddee"
```

#### squeeze squeeze!

- 指定した文字が複数並んでいたら1文字に圧縮する
- 複数のパターンを指定すると全てのパターンに含まれる文字列のみ圧縮する

```ruby
'aabbccddaabbccdd'.squeeze('b')
=> "aabccddaabccdd"

'aabbccddaabbccdd'.squeeze('a-c')
=> "abcddabcdd"

'aabbccddaabbccdd'.squeeze('a-c', 'b-d')
=> "aabcddaabcdd"
```

#### replace

- 置換ではなく、指定した文字列で自分自身の内容を破壊的に変更する
- ぶっちゃけ使わない

```ruby
a = 'aabbcc'
a.replace('hage')
a
=> "hage"
```

### 文字列の連結

異なるエンコーディングの文字列を連結しようとした時にはエラー、異なるエンコーディングだがASCII文字列なら結合可能、なのはもう説明しなくてもいいですよね

#### +

文字列を結合した新しいオブジェクトを生成する

```ruby
'abc' + 'def'
=> "abcdef"
```

#### \<< concat

元のオブジェクトを破壊的に追加する

```ruby
a = 'abc'
a.concat('def')
a
=> "abcdef"

a = 'abc'
a << 'def'
a
=> "abcdef"
```

#### *
















### 大文字、小文字への変換

| capitalize | capitalize! |
| downcase   | downcase!   |
