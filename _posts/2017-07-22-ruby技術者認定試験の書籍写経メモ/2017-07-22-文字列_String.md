## 文字列 String

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

1.9よりStringオブジェクトはエンコーディング情報を保持するようになった。この為、Stringオブジェクトのメソッドは1文字を単位として動くように変わった

#### 主な文字コード

| UTF-8       | 主に使用されている文字コード                                                  |
| EUC-JP      | 古いUNIXシステムで利用されていたコード                                        |
| JIS         | JISで策定された7bit文字のみを使った文字コード                                 |
| Shift_JIS   | マルチバイト文字とASCII文字を切り替えることなく使用できるようにした文字コード |
| Windows-31J | 主にWindowsで使われていたShift-JISの亜種                                      |
| US-ASCII    | ASCII文字だけで構成されている文字コード                                       |

### 文字列のエンコーディングの取得

String#encodingメソッドはEncodingクラスのインスタンスを返す

```ruby
'aaa'.encoding
=> #<Encoding:UTF-8>
```

### 文字列のエンコーディングの変更

String#encode String#Encode!

```ruby
'aaa'.encode('EUC-JP').encoding
=> #<Encoding:EUC-JP>
```

### 文字列の比較

| ==      | そ                            |
| >       | の                            |
| >=      | ま                            |
| <       | ん                            |
| <=      | ま                            |
| <=>     | 件のUFO演算子 左が大きければ1 |
| casecmp | 文字の大小を無視してUFO演算子 |

### 文字列と異なるクラスのオブジェクトの比較

== メソッドのみ、異なるクラスのオブジェクトと比較できるが、型の自動変換は行われないので結果はfalseとなる

```ruby
'100' == 100
=> false

'100' >= 100
ArgumentError: comparison of String with 100 failed
```

### 文字列の比較時のエンコーディング

- 文字列の比較のときにもエンコーディングを意識する必要がある
- == eql? メソッドは両者が同じエンコーディングでなければfalseを返す。ただし、ASCII文字しか含んでいない場合にはtrueを返す

```ruby
'もこ' == 'もこ'
=> true

'もこ' == 'もこ'.encode('EUC-JP')
=> false

'ABC' == 'ABC'.encode('EUC-JP')
=> true
```

### 文字列の分割

split メソッドは文字列や正規表現にて文字列を分割する

```ruby
'abcde'.split('c')
=> ["ab", "de"]

'abcde'.split(/c/)
=> ["ab", "de"]
```

### 文字列の切り出し

- [] slice slice! メソッドに数値を渡し、場所を指定して文字列を切り出す
- slice!は元の文字列から破壊的に切り出す

```ruby
'abcde'[2]
=> "c"

'abcde'.slice(2)
=> "c"

'abcde'[-2]
=> "d"

'abcde'.slice(-2)
=> "d"

a = 'abcde'

a.slice!(2)
=> "c"

a
=> "abde"
```

範囲オブジェクトを渡すと該当する範囲が対象になる

```ruby
'abcde'[1..3]
=> "bcd"

'abcde'.slice(1..3)
=> "bcd"

a = 'abcde'

a.slice!(1..3)
=> "bcd"

a
=> "ae"
```

- 範囲の指定は範囲オブジェクトだけではなく、開始位置、長さ　で渡すこともでき
- 特に開始位置はマイナスを渡すと末尾から数えた数になる、といういつものあの動きをする
- 文字列よりも長い長さが渡されても可能な部分だけ返してくれる

```ruby
'abcde'[1, 3]
=> "bcd"

'abcde'.slice(1, 3)
=> "bcd"

a = 'abcde'

a.slice!(1, 3)
=> "bcd"

a
=> "ae"
```

- 文字列で指定すると元の文字列に含まれていればその部分を、含まれていなければnilを返す
- 最初に一致した箇所だけが対象
- ぶっちゃけ使わない

```ruby
'abcdeabcde'['bc']
=> "bc"

'abcdeabcde'.slice('bc')
=> "bc"

a = 'abcdeabcde'

a.slice!('bc')
=> "bc"

a
=> "adeabcde"
```

- 正規表現でも指定できるらしい
- 最初に一致した箇所だけが対象
- ぶっちゃけ使わない

```ruby
'abcdeabcde'[/bc/]
=> "bc"

'abcdeabcde'.slice(/bc/)
=> "bc"

a = 'abcdeabcde'

a.slice!(/bc/)
=> "bc"

a
=> "adeabcde"
```

### 文字列の変更

- 文字列の一部分を変更することができる
- []= メソッドには前項でやったような色々な指定方法が使える
- insert メソッドもあるよ たぶん使わないけど

```ruby
a = 'abcdeabcde'
a[3] = '_hage_'
a
=> "abc_hage_eabcde"

a = 'abcdeabcde'
a[3, 2] = '_hage_'
a
=> "abc_hage_abcde"

a = 'abcdeabcde'
a[3..4] = '_hage_'
a
=> "abc_hage_abcde"

a = 'abcdeabcde'
a['bc'] = '_hage_'
a
=> "a_hage_deabcde"

a = 'abcdeabcde'
a[/bc/] = '_hage_'
a
=> "a_hage_deabcde"
```

```ruby
a = 'abcdeabcde'
a.insert(3, '_hage_')
a
=> "abc_hage_deabcde"
```

### 文字列の一部を置換

| sub      | sub!     |
| gsub     | gsub!    |
| tr       | tr!      |
| tr_s     | tr_s!    |
| delete   | delete!  |
| squeeze  | squeeze! |
| replace  | 　       |

- それぞれ置換した文字列を返すが、!が付いているメソッドは元の文字列を破壊的に変更する
- replaceメソッドはそれ自体が破壊的なので!は付いていない

#### sub sub!

指定したパターンに最初にマッチした箇所を指定した文字列に変更する

```ruby
'abcabc'.sub('bc', '_hage_')
=> "a_hage_abc"

'abcabc'.sub(/bc/, '_hage_')
=> "a_hage_abc"

a = 'abcabc'
a.sub!('bc', '_hage_')
a
=> "a_hage_abc"
```

#### gsub gsub!

指定したパターンにマッチした箇所を全て指定した文字列に変更する

```ruby
'abcabc'.gsub('bc', '_hage_')
=> "a_hage_a_hage_"

'abcabc'.gsub(/bc/, '_hage_')
=> "a_hage_a_hage_"

a = 'abcabc'
a.gsub!('bc', '_hage_')
a
=> "a_hage_a_hage_"
```

また、ブロックを取ることもでき、実行結果へと置換される

```ruby
'abcabc'.sub('bc') do |match_data|
  "_#{match_data}_"
end
=> "a_bc_abc"
```

```ruby
'1_2_3'.gsub(/\d/) do |match_data|
  match_data.to_i + 5
end
=> "6_7_8"
```





a
