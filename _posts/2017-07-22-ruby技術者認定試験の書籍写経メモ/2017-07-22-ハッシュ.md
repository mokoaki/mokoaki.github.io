## ハッシュ

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-ruby技術者認定試験の書籍写経メモ %})

- いわゆる連想配列
- 1.9からハッシュに含まれる要素の順番が追加された順序で保持されるようになった

### ハッシュの生成

ハッシュのキーには任意のオブジェクトが使えるが、シンボルがよく使われる。理由は後述

#### リテラル

旧記法

```ruby
{:a => 1}
=> {:a=>1}

{:a => 1}.class
=> Hash
```

1.9からの新記法

```ruby
{a: 1}
=> {:a=>1}

{a: 1}.class
=> Hash
```

2.2からの新記法

```ruby
{'a': 1, 'b-c': 2}
=> {:a=>1, :"b-c"=>2}

{'a': 1, 'b-c': 2}.class
=> Hash
```

#### Hash.[] メソッド

この方法は積極的に使う理由がない限り使う必要は無いでしょう

```ruby
Hash[1, 2, 3, 4]
=> {1=>2, 3=>4}
```

#### Hash.new メソッド

newメソッドを使用した場合、キーが存在しない場合のデフォルト値を設定できます　がぶっちゃけ使いません

```ruby
h = Hash.new('test')

h.class
=> Hash

h[:hage]
=> '"test"'
```

初期値はハッシュ作成後でも変更できる

```ruby
h = Hash.new('test')

h.default
=> "test"
```

```ruby
h = {}

h[:hage]
=> nil

h.default
=> nil

h.default = 'test'

h.default
=> 'test'

h[:hage]
=> 'test'
```

- newメソッドはブロックを取ることができる
- このブロックは新規キーを読み取り参照した時に処理される

```ruby
h = Hash.new do |hash, key|
  p '= access new key'
  p hash, key

  hash[key] = (key == :hage1 ? 'a' : 'b')
end

h.class
=> Hash

h[:hage1]
"= access new key"
{}
:hage1
=> "a"

h[:hage1]
=> "a"

h[:hage2]
"= access new key"
{:hage1=>"a"}
:hage2
=> "b"

h[:hage2]
=> "b"

h[:hage3]
"= access new key"
{:hage1=>"a", :hage2=>"b"}
:hage3
=> "b"

h[:hage3]
=> "b"
```

参照ではなく、キーと値の新規設定時には動作しない。動作する必要もないし

```ruby
h = Hash.new do |hash, key|
  p '= access new key'
  p hash, key

  hash[key] = (key == :hage1 ? 'a' : 'b')
end

h.class
=> Hash

h[:hage1] = 'hage-!'
=> "hage-!"
```

- この初期値設定ブロックは Hash#default_proc で後から参照できる
- まぁいじる事は無いと思うけど・・

```ruby
h = Hash.new do |hash, key|
  hash[key] = (key == :hage1 ? 'a' : 'b')
end

h.class
=> Hash

h.default_proc
=> #<Proc:0x007fcaa10af730@(irb):77>
```

#### Array#to_h

ぶっちゃけ使わないけど

```ruby
[[:a, 1], ['b', 2]].to_h
=> {:a=>1, "b"=>2}
```

### ハッシュのキーや値を参照する

| []        |
| keys      |
| values    |
| values_at |
| fetch     |
| select    |

#### [] メソッド

そのまんま

```ruby
h = {a: 1}

h[:a]
=> 1
```

#### keys メソッド

ハッシュの全てのキーの配列を生成する

```ruby
{a: 1, b: 2, c: 3, d: 4}.keys
=> [:a, :b, :c]
```

#### values メソッド

ハッシュの全ての値の配列を生成する

```ruby
{a: 1, b: 2, c: 3, d: 4}.values
=> [1, 2, 3]
```

#### values_at メソッド

複数の引数を取り、指定されたキーに対応する値による配列を生成する

```ruby
{a: 1, b: 2, c: 3, d: 4}.values_at(:a, :c)
=> [1, 3]
```

#### fetch メソッド

キーが存在する場合は値を返すのみ、下記以降の例でもそれは変わらない

```ruby
{a: 1, b: 2, c: 3, d: 4}.fetch(:a)
=> 1
```

- キーが存在しない場合
  - 引数がキーのみの場合、KeyError例外が発生

```ruby
{a: 1, b: 2, c: 3, d: 4}.fetch(:z)
KeyError: key not found: :z
```

- キーが存在しない場合
  - 引数が2つの場合、第2引数を返す

```ruby
{a: 1, b: 2, c: 3, d: 4}.fetch(:z, 'test')
=> "test"
```

- キーが存在しない場合
  - ブロックを取っている場合は、キーが存在しない場合にブロックの評価結果を返す

```ruby
{a: 1, b: 2, c: 3, d: 4}.fetch(:z) do |key|
  key.to_s
end
=> "z"
```

#### select メソッド

- キーと値の組み合わせにおいてブロックを評価し、結果がtrueになる結果のキーと値を返す
- 1.8以前は配列を返す
- 1.9以降はハッシュを返す

```ruby
{a: 1, b: 2, c: 3, d: 4}.select do |key, value|
  value % 2 == 0
end
=> {:b=>2, :d=>4}
```

### ハッシュを変更する

| []=       | 　      | 　        |
| delete    | 　      | 　        |
| reject    | reject! | delete_if |
| replace   | 　      | 　        |
| shift     | 　      | 　        |
| merge     | 　      | 　        |
| update    | 　      | 　        |
| invert    | 　      | 　        |
| clear     | 　      | 　        |

#### []= メソッド

- キーが存在しない場合には登録し値を設定
- キーが存在するなら値を変更
- まぁそのまんま

```ruby
h = {}

h[:a]
=> nil

h[:a] = 'hage-!'

h[:a]
=> "hage-!"
```

#### delete メソッド

指定されたキーと値を取り除く

```ruby
h = {a: 1, b: 2, c: 3, d: 4}

h
=> {:a=>1, :b=>2, :c=>3, :d=>4}

h.delete(:b)
=> 2

h
=> {:a=>1, :c=>3, :d=>4}
```

指定したキーが存在しなければ戻り値はnil

```ruby
h = {a: 1, b: 2, c: 3, d: 4}

h
=> {:a=>1, :b=>2, :c=>3, :d=>4}

h.delete(:z)
=> nil

h
=> {:a=>1, :b=>2, :c=>3, :d=>4}
```

ブロックを取った場合、キーが存在しない場合にブロックの評価結果を返す

```ruby
h = {a: 1, b: 2, c: 3, d: 4}

h
=> {:a=>1, :b=>2, :c=>3, :d=>4}

h.delete(:z) do |key|
  p "Not found #{key}"
  key
end
"Not found z"
=> :z
```

#### reject reject! delete_if メソッド

キーと値毎にブロックを評価し、結果がtrueとなったキーと値を取り除いたハッシュを生成する

```ruby
{a: 1, b: 2, c: 3, d: 4}.reject do |key, value|
  value % 2 == 0
end
=> {:a=>1, :c=>3}
```

reject!とdelete_ifは同じ動作となり、自己を破壊的に変更する

```ruby
h = {a: 1, b: 2, c: 3, d: 4}

h.reject! do |key, value|
  value % 2 == 0
end
=> {:a=>1, :c=>3}

h
=> {:a=>1, :c=>3}
```


#### replace メソッド

自分自身のオブジェクトIDを変えることなく、引数で指定されたハッシュで自分自身の内容を置き換えます

```ruby
a = {a: 1, b: 2}
b = {c: 3, d: 4}

a
=> {:a=>1, :b=>2}

a.object_id
=> 70254130865000

a.replace(b)
=> {:c=>3, :d=>4}

a
=> {:c=>3, :d=>4}

a.object_id
=> 70254130865000
```

#### shift メソッド

- キーと値のペアを1つ取り除き、それを返す
- **どのキーと値のペアが取り除かれるかは不定**・・とこの本には書いてあるが、**追加した順に取得できるとしか思えない**がどうなのだろう

```ruby
h = {}

h[:a] = 1
h[:b] = 2
h[:c] = 3

h.shift
=> [:a, 1]

h.shift
=> [:b, 2]

h.shift
=> [:c, 3]
```

------------------------------



### メソッド呼び出し時の実引数の波カッコの省略

- ぶっちゃけ使わないかな？
- 最後の引数だけ有効

```ruby
def moko(a, b, c)
  p a
  p b
  p c
end

moko(1, 2, a: 1, 'b' => 2)
1
2
{:a=>1, "b"=>2}
=> {:a=>1, "b"=>2}

# 引数の数的に考えて、残りの部分がハッシュとして解釈できそうなら、
moko(1, 2, { a: 1, 'b' => 2 })
# こう書いたかの如く動作するよ！って事だわな

```

[キーワード引数]({% post_url 2017-07-22-クラス、オブジェクト指向、メソッド探索経路 %}#キーワード引数) も併せて理解しておくべし
