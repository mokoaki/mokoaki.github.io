## Ruby 特異クラス？無名クラス？シングルトンクラス？extend？singleton_methods？飾らない真実メモ

(_ _) わたくし如きが偉そうに言い切っちゃってすいません

#### 特異クラス？無名クラス？シングルトンクラス？

- 人によって用語が違う
- もともと特異クラスは無名だ
- 「全てのオブジェクトが持っている、Object#singleton_classでアクセスできる彼だけの特異クラス」を「シングルトンクラス」と呼べばいいのに「特異クラス」と言っているからややこしくなる

#### わたくしの主張

- 「特異クラス」「無名クラス」は同じものを指している
- 「特異クラス」「シングルトンクラス」の使い分け
  - 「特異クラス」の内、Object#singleton_classにて意図的にアクセスできるクラスは「シングルトンクラス」と呼ぶ
  - 「メソッド探索ルートにextendされたクラス」は「特異クラス」だが「シングルトンクラス」ではない
- 「特異メソッド」「シングルトンメソッド」の使い分け
  - 「特異クラス」に定義されているメソッドは「特異メソッド」と呼ぶ
  - 「特異メソッド」の内、「シングルトンクラス」に定義されているメソッドは「シングルトンメソッド」と呼ぶ
  - 「メソッド探索ルートにextendされたクラスに定義してあるメソッド」は「特異メソッド」だが「シングルトンメソッド」ではない
- 人に合わせる


### Object#extend(Module) は「指定したmoduleのメソッドをレシーバの特異メソッドとして追加する」

- **正確ではない**
- レシーバのシングルトンクラスの直上に特異クラスを挿入しmoduleを取り込む
- レシーバのシングルトンクラスにメソッドを追加するわけではない
- レシーバのシングルトンクラスに include, prepend しても同様
- もちろん、レシーバ.singleton_methods(false) には現れない

### Module#singletom_methods(false) は 「レシーバの特異メソッドを返す」

- **正確ではない**
- レシーバのシングルトンクラスに定義されているメソッドのみを返す
- レシーバのシングルトンクラスのancestors内のクラス達は無視するということ

### Module#singletom_methods(true)

- 世の中の singletom_methods(true) の説明はほぼいいと思います
- レシーバのシングルトンクラスのancestors内のクラスに定義されているメソッド達を**投影的**に返す

### Module#include(Module)

- 世の中の prepend の説明はほぼいいと思います
- レシーバが「私を探索してもメソッドは見つからなかったのか、残念だ。スーパークラスを探索するなら、先に探索して欲しいクラス達があるんだが」と差し出すクラス達を追加する

### Module#prepend(Module)

- 世の中の prepend の説明はほぼいいと思います
- レシーバが「私のメソッドを探索するなら、先に探索して欲しいクラス達があるんだが」と差し出すクラス達を追加する
