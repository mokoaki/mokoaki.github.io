## Rubyのメタプログラミングの書籍写経メモ

某書を写経したメモ

### 少女M

#### メタプログラミングとは

- コードを記述するコードを記述することである
- 言語要素を実行時に操作するコードを記述することである

### オブジェクトモデル

- インスタンスにはインスタンス変数とクラスへの参照があるのみ、メソッドはクラスに存在する
- クラスにはクラスインスタンス変数とスーパークラスへの参照がある、クラスメソッドは特異クラスに存在する
- オブジェクトのメソッドはそのクラスのインスタンスメソッドであるように、
- クラスのメソッドはClassクラスのインスタンスメソッドである
- ネームスペース
  - 定数
    - ```ruby
      module A
        module B
          C = 'A_B_C'
        end

        p B::C
        # => "A_B_C"
      end

      p A::B::C
      # => "A_B_C"
      ```
    - ```ruby
      B = 'B'
      module A
        B = 'A_B'

        p B
        # => "A_B"

        p ::B
        # => "B"
      end
      ```
    - ```ruby
      # レシーバ内部の定数一覧
      A::B.constants
      # => [:C]
      
      # トップレベルの定数一覧
      Module.constants
      # => [.....]
      ```
    - ```ruby
      # パスの取得もできる 
      module A
        class B
          module C
            p Module.nesting
            # => [A::B::C, A::B, A]
          end
        end
      end
      ```
    - load は定数が既存の定数を汚染する可能性がある　そういう場合には load(path, true) を使うと無名モジュールでラッピングし解釈、その後破棄してくれる
    - require は定数等を取り込むためのものである為、そういう心配も機能も無い
  - メソッド探索
    - メソット呼び出し
      - メソッド探索を行う
        - 継承チェーン
          - Rubyがクラスに入り、メソッドを見つけるまで継承チェーンを登る
          - object.singleton_class.ancestors
          - include module
          - prepend module
          - 継承チェーンに既に存在しているモジュールはインクルードされない。無視される
          - ```ruby
            module M1
            end

            p M1.ancestors
            #=> [M1]

            module M2
              include M1
            end

            p M1.ancestors
            #=> [M1]

            p M2.ancestors
            #=> [M2, M1]

            module M3
              prepend M1
              include M2
            end

            p M1.ancestors
            #=> [M1]

            p M2.ancestors
            #=> [M2, M1]

            p M3.ancestors
            #=> [M1, M3, M2] # include M2 しようとした時に「あ、M1はもう居るじゃん、君は無しね」となる
            # まぁ、[M1, M3, M2, M1]で前方優先でユニークにした、と考えてもいいのかもしれない
            ```
        - KernelはObjectがインクルードしているので全てのオブジェクト内で使用できる
          - 例えばこいつら
          - ```ruby
            Kernel.private_instance_methods.grep(/\Ap/)
            # => [:printf, :print, :putc, :puts, :p, :proc]
            ```
          - kernelにメソッドを追加すれば、同じようにどこからでも使えるカーネルメソッドが作れるということ
      - メソッド呼び出しには self が必要
        - レシーバがselfになる
        - Rubyのコードはオブジェクト（カレントオブジェクト）内で実行される。それはレシーバであり、self である
        - インスタンス変数も、レシーバ無しで呼び出されるメソッドもselfのものが対象である
        - 常にselfを意識すべきである。最後にレシーバとなったオブジェクトを追いかければよい
        - メソッド探索は毎回メソッド探索チェーンを下から探索する。近くに見つかったからと言ってそれを呼び出すわけではない
        - ```ruby
          module A
            def moko
              hage
            end
            
            def hage
              'A::HAGE'
            end
          end

          module B
            def hage
              'B::HAGE'
            end
          end

          class C
            include A
            include B
          end

          p C.new.moko
          # => "B::HAGE"
          ```
        - トップレベルコンテキスト
          - Rubyのコードはオブジェクト内で実行されるなら、例えばirbを起動した直後、クラス定義でもモジュール定義でもメソッド定義でもない、今はどこに居るのだろうか？
            - ご存知、mainオブジェクト内です
        - クラス定義、モジュール定義内では self は自分そのものとなる
        - 例外 Refinements
          - refine と using を覚えてればいいんじゃね
          - ```ruby
            module R
              refine String do
                def hage
                  'hage-!'
                end
              end
            end

            module M
              # このモジュール内でのみ、refineが有効になる
              using R

              p ''.hage
            end
            ```
