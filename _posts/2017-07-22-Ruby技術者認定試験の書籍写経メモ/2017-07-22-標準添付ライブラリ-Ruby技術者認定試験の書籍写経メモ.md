## 標準添付ライブラリ

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-Ruby技術者認定試験の書籍写経メモ %})

- 標準添付ライブラリはRubyに付属しているライブラリ
- 組み込みライブラリと違う点はrequire等でライブラリをロードする必要がある
- Ruby技術者認定試験の出題範囲はGold

```ruby
pp []
=> NoMethodError: undefined method 'pp'

require 'pp'
=> true

pp []
[]
=> []
```

## StringIO

- 文字列をIOクラスと同じインターフェイスで取り扱う為のクラス
- IOクラスとの継承関係はないオブジェクト内のバッファに文字列を格納したり取り出したりする

#### バッファとポインタ

あれ？（少なくとも）Ruby2.4ではrequireしなくても使えたわ

| バッファ | StringIO#string | デフォは "" |
| ポインタ | StringIO#pos    | デフォは 0  |

```ruby
sio = StringIO.new

sio.string
=> ""

sio.pos
=> 0
```

- StringIO#string は設定も取得もできる
- 設定するとポインタは0に戻るっぽい（modeによるのかも）

```ruby
sio = StringIO.new

sio.string
=> ""

sio.pos
=> 0

sio.string = '12345'

sio.pos
=> 0

sio.gets
=> "12345"

sio.pos
=> 5
```

#### StringIO#puts

- 引数の文字列をバッファへ格納し、ポインタを移動する
- 格納されるバッファには改行が付加される（put系ぽい）
- ポインタはバッファ上にて追加された文字列と改行の後に移動する

```ruby
sio = StringIO.new
=> #<StringIO:0x007fdf310478c0>

sio.puts('12345')
=> nil

sio.string
=> "12345\n"

sio.pos
=> 6
```

#### StringIO#gets

- 現在のポインタから改行（もしくは末尾）までの文字列を返し、ポインタを移動する
- 返される文字列には改行が付加される（put系ぽい）
- ポインタはバッファ上にて、返した文字列と改行の後に移動する

```ruby
sio = StringIO.new
=> #<StringIO:0x007fdf310478c0>

sio.puts('12')
sio.puts('34')

sio.string
=> "12\n34\n"

sio.pos
=> 6

sio.gets
=> nil

sio.pos = 0

sio.gets
=> "12\n"

sio.pos
=> 3
```

#### インスタンス生成

| new  | インスタンスを返す                  |
| open | ブロックの評価結果を返す            |
| open | ブロックを取らない場合は new と同じ |

```ruby
StringIO.new(string = '', mode = 'r+')
StringIO.open(string = '', mode = 'r+')
StringIO.open(string = '', mode = 'r+') { |sio| ... }
```

#### mode r

- 読み込みモード
- ポインタは先頭を指す

```ruby
StringIO.open('1234', 'r') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('a')
  #=> IOError: not opened for writing
end
=> "string:1234, pos:0"
```

#### mode w

- 書き込みモード
- バッファは空になる
- 当然ポインタは先頭

```ruby
StringIO.open('1234', 'w') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  p sio.gets
  #=> IOError: not opened for reading
end
=> "string:, pos:0"
```

#### mode a

- 書き込みモード
- ポインタは末尾を指す
- ・・ポインタは末尾じゃなくて0を指しているように見えるけど、putsしたら末尾に出力するし、ポインタも末尾に移動したんでまぁいいか

```ruby
StringIO.open('1234', 'a') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:1234AB\n, pos:7"
```

#### mode r+

- 読み書きモード
- ポインタは先頭を指す

```ruby
StringIO.open('1234', 'r+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:AB\n4, pos:3"
```

#### mode w+

- 読み書きモード
- バッファは空になる

```ruby
StringIO.open('1234', 'w+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:, pos:0"
```

#### mode a+

- 読み書きモード
- ポインタは末尾を指す
- ・・ポインタは末尾じゃなくて0を指しているように見えるけど、putsしたら末尾に出力するし、ポインタも末尾に移動したんでまぁいいか

```ruby
StringIO.open('1234', 'a+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:1234AB\n, pos:7"
```

#### StringIO#putc

- 現在のポインタの位置に1文字だけ書き込む
- 引数に2文字以上を渡しても先頭以外は無視される
- もちろんポインタは1つずれる

```ruby
StringIO.open('1234', 'r+') do |sio|
  sio.pos = 2
  p sio.putc('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:12A4, pos:3"
```

#### String#print StringIO#puts

- String#print と StringIO#puts は殆ど同じ動作をする（どうやらウソのようです）
- 末尾に改行を付加するかどうかが違う
- 複数の引数、もしくは配列を取る

```ruby
StringIO.open do |sio|
  p sio.puts('A', 'B')
  p sio.puts(['C', 'D'])
  p sio.print(['E', 'F'])
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:A\nB\nC\nD\n[\"E\", \"F\"], pos:18"
```

#### StringIO#printf

まぁいつものアレ

```ruby
StringIO.open do |sio|
  p sio.printf('%02d', 1)
  p "string:#{sio.string}, pos:#{sio.pos}"
end
"string:01, pos:2"
```

#### StringIO#read

- 現在のポインタから引数に指定した文字数分、文字を取り出す
  - その前に終端になったらそこまで返す
- 既にポインタが終端を指していたら nil を返す
- 第1引数を省略したなら
  - 終端までを返す
  - 既にポインタが終端だったら空文字が返る
- 第2引数を指定したらその変数に取り出した文字列を格納する（あたまおかしい？）

ぶっちゃけややこしい

```ruby
StringIO.open('1234') do |sio|
  p sio.read
end
=> "1234"
```

```ruby
StringIO.open('1234') do |sio|
  sio.pos = 2
  p sio.read
end
=> "34"
```

```ruby
StringIO.open('1234') do |sio|
  sio.pos = 2
  p sio.read(1)
end
=> "3"
```

#### StringIO#getc StringIO#readchar

現在のポインタから1文字取得する

```ruby
StringIO.open('123') do |sio|
  sio.pos = 1
  p sio.getc
  p sio.getc
  p sio.getc
end
=> "2"
=> "3"
=> nil
```

readchar は似たような動作だが、終端でエラーが発生する

```ruby
StringIO.open('123') do |sio|
  sio.pos = 1
  p sio.readchar
  p sio.readchar
  p sio.readchar
end
=> "2"
=> "3"
=> EOFError: end of file reached
```

#### StringIO#gets StringIO#readline

現在のポインタから改行までの文字列を取得する

```ruby
StringIO.open("123\n456") do |sio|
  sio.pos = 1
  p sio.gets
  p sio.gets
  p sio.gets
end
=> "23\n"
=> "456"
=> nil
```

readline は似たような動作だが、終端でエラーが発生する

```ruby
StringIO.open("123\n456") do |sio|
  sio.pos = 1
  p sio.readline
  p sio.readline
  p sio.readline
end
=> "23\n"
=> "456"
=> EOFError: end of file reached
```

#### StringIO#pos= StringIO#seek

ポインタを移動する

- pos= は先頭を0とした絶対位置に移動する（マイナスは指定できないぽい）
- seek は第2引数を基準として相対位置に移動する
  - IO::SEEK_SET ファイル先頭（デフォ）
  - IO::SEEK_CUR 現在のポインタ位置
  - IO::SEEK_END ファイル末尾

```ruby
StringIO.open("123\n456") do |sio|
  sio.seek(-2, IO::SEEK_END)
  p sio.getc
end
=> "5"
```

## YAML

- 簡単な記法でデータの階層構造を表記できるフォーマット
- ハッシュ・配列の組み合わせをスペース・インデントで表現する

```ruby
require 'yaml'

yaml_data = <<-DATA
data_array:
  - a
  - b
  - c
data_key_value:
  key1: value1
  key2: value2
DATA

yaml = YAML.load(yaml_data)
=> {"data_array"=>["a", "b", "c"], "data_key_value"=>{"key1"=>"value1", "key2"=>"value2"}}

yaml.class
=> Hash
```

#### YAML.load_file

ファイルを直接読み込んでオブジェクトを生成する

```ruby
require 'yaml'

YAML.load_file('path/to/yaml_file')
```

### YAML.load_stream

- --- までが一つのデータの区切りとみなされ、通常(YAML.load等)は以降は無視される
- が、YAML.load_stream はデータを順番にYAML::stream で返す
- ・・・らしいが、何かそんなインスタンスじゃないのが返って来るんだけど？ 文字列を渡した時とIOインスタンスを渡した時で変わる？

```ruby
require 'yaml'

yaml_data = <<-DATA
- a
---
- b
DATA

yaml = YAML.load(yaml_data)
=> ["a"]

yaml.class
=> Array

yaml = YAML.load_stream(yaml_data)
=> [["a"], ["b"]]

yaml.class
=> Array
```

IOインスタンスを渡す方が実際の使い方？

```ruby
yaml = YAML.load_stream(open('path/to/yaml_file'))
```

#### YAML.load_document

こんなことも出来るらしいけど、ホントこの書籍はやる気ないわ　俺のやる気も失せるわ

```ruby
YAML.load_document(open('path/to/yaml_file')) do |yaml|
  yaml.first
end
```

#### YAML.dump

オブジェクトをyaml形式の文字列にして返す

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

YAML.dump(moko)
=> "---\n:homo: true\n:homos:\n- :a\n- :b\n"
```

第2引数にIOオブジェクトを渡すとそちらに書き込む

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

sio = StringIO.new

YAML.dump(moko, sio)

sio.string
=> "---\n:homo: true\n:homos:\n- :a\n- :b\n"
```

#### YAML.dump_stream

- 複数のオブジェクトを引数に取れる
- からなんだってんだよな

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

YAML.dump_stream(moko, moko.dup)
=> "---\n:homo: true\n:homos: &1\n- :a\n- :b\n---\n:homo: true\n:homos: *1\n"
```

## JSON

- Ruby1.9から標準添付ライブラリに追加された
- YAMLみたいに簡単な記法でデータの階層構造を表現できる
- to_str, to_io, readメソッドを持つオブジェクトなら文字列以外も渡せる（えーと？）

#### JSON.parse JSON.load

```ruby
require 'json'

json_data = <<-DATA
{"homo": true, "homos": ["a", "b"]}
DATA

json = JSON.parse(json_data)
=> {"homo"=>true, "homos"=>["a", "b"]}

json.class
=> Hash
```

JSON.parse は第2引数に 要素を読み込む毎のオプションがあったりする

- max_nesting : 入れ子になっているデータの最大の深さを指定
- symbolize_names: 真を指定するとハッシュのキーを文字列ではなくシンボルに

JSON.load は第2引数に 要素を読み込む毎に呼び出されるProcオブジェクトを渡せる
渡した所で何の役に立つのか謎
今回の例で言うと配列を順番に渡し、最後に配列を渡す。jsonの評価結果に影響を及ぼさないなら何の意味が・・？

```ruby
require 'json'

json_data = <<-DATA
[1, 2]
DATA

json = JSON.load(json_data, lambda { |i| p i * 2 })
=> 2
=> 4
=> [1, 2, 1, 2]
=> [1, 2]

json
=> [1, 2]
```

#### JSON.parse(IO)

JSON.load_file 的なメソッドは用意されていないが、IOから読み込むことが出来る

```ruby
require 'json'

File.open('path/to/json_file') do |f|
  JSON.load(f)
end
```

```ruby
require 'json'

sio = StringIO.new('["a", "b"]')

JSON.load(sio)
=> ["a", "b"]
```

#### JSON.dump(object, io = nil, imit = nil)
- 第2引数を省略すると文字列として取得
  - ioを指定するとIOに書き込む
- 第3引数limitはダンプするオブジェクトの深さを制限することが出来る

```ruby
require 'json'

sio = StringIO.new()

JSON.dump({hoge: ["a", "b"]}, sio)

sio.string
=> "{\"hoge\":[\"a\",\"b\"]}"
```

## CSV

#### CSV.parse

- CSV.parse(csv_data)
- CSV.parse(csv_data) { |row| ... }

ブロックを渡すと行毎に処理ができる
 
```ruby
require 'csv'

csv_data = <<-DATA
a,b,c
d,e,f
DATA

csv = CSV.parse(csv_data)
=> [["a", "b", "c"], ["d", "e", "f"]]
```

```ruby
require 'csv'

csv_data = <<-DATA
a,b,c
d,e,f
DATA

csv = CSV.parse(csv_data) do |row|
  p row
end
=> ["a", "b", "c"]
=> ["d", "e", "f"]
```

#### CSV.open

- CSV.open('path/to/csv_file', option = {})
- CSV.open('path/to/csv_file', option = {}) { |row| ... }
- CSV.open('path/to/csv_file', mode = 'rb', option = {})
- CSV.open('path/to/csv_file', mode = 'rb', option = {}) { |row| ... }


- ブロックを渡すと行毎に処理ができる
- オプションで改行コードを指定したりできる

### mode

| r  | 読み込み         |
| w  | 書き込み         |
| rb | バイナリ書き込み |
| wb | バイナリ書き込み |

```ruby
require 'csv'

CSV.open('path/to/csv_file') do |row|
  row.each do |col|
    col
  end
end
```

#### CSVデータの書き込み

ブロックを渡すパターンと渡さないパターン

```ruby
require 'csv'

CSV.open('temp1.csv', 'w') do |row|
  row << [1, 2, 3, 4]
  row << [5, 6, 7, 8]
end

csv = CSV.open('temp2.csv', 'w')
csv << [1, 2, 3]
csv << [4, 5, 6]
csv.close
```

```sh
$ cat temp1.csv
1,2,3,4
5,6,7,8

$ cat temp2.csv
1,2,3
4,5,6
```

## CSV.foreach CSV.read CSV.readlines

- CSV.foreach ブロック引数にEnumeratorオブジェクトで各行を受け取る
- CSV.read CSV.readlines 内部の処理は違うが結局は配列の配列を受け取る

正直、何のために複数のメソッドになっているのか謎

## FileUtils

- 基本的なファイル操作を集めたライブラリ
- ファイルやディレクトリの操作はDirやFileでも行えるが、FileUtilsはUNIXコマンドライクに呼び出しやすく扱いやすくしたもの
- だからこそ、どっちを使うのか、今どっちを使っているのかちゃんと意識すべし
- FileUtilsはモジュール関数として実装されているのでincludeしてもよし
- 殆どのコマンドはoptionとして (noop: true(実際には実行しない), verbose: true(詳細をコンソール表示)) 等が渡せる 
- ぶっちゃけ ファイル、ディレクトリ操作は FileUtils を使えばいいんだよ

#### FileUtils.cd(dir, options = {})

カレントディレクトリを引数dirに変更する
ブロックを渡すとブロック内部のみカレントディレクトリが変わる

#### FileUtils.pwd

カレントディレクトリを文字列で返す

```ruby
require 'fileutils'

FileUtils.pwd
=> "/Users/mokoaki/xxxx/xxxx"

FileUtils.cd('/Users') do |a|
  p a
  p FileUtils.pwd
end
=> "/Users"
=> "/Users"

FileUtils.pwd
=> "/Users/mokoaki/xxxx/xxxx"
```

#### FileUtils.cp FileUtils.copy(src, dest, options = {})

- エイリアスで同じ動作
- ファイルをコピーする
- srcがファイルでなければエラー
- destがファイルならそのファイルとして上書き、destがディレクトリならそのディレクトリ以下にsrcをコピーする

#### FileUtils.cp_r(src, dest, options = {})

- 再帰的にファイルをコピーする
- srcをdestにコピーする
- srcがディレクトリであったら再帰的にコピーする
- destがディレクトリならdest/srcにコピーする
- srcを配列にて指定する事も出来る

#### FileUtils.mv FileUtils.move(src, dest, options = {})

- エイリアスで同じ動作
- ファイルを移動する　あれ？ディレクトリは？
- srcを配列にて指定する事も出来る
- srcが1つの場合
  - descが存在しない場合、それがファイル名であるかのように移動される
  - descが存在する
    - descがディレクトリの場合、srcをdest/srcに移動する
    - descがファイルの場合、上書きする
- srcに配列を指定した場合
  - destがディレクトリでなければエラー
  - descがディレクトリであれば移動 src[0] => dest/src[0], src[1] => dest/src[1]

ぶっちゃけややこしい！

#### FileUtils#rm FileUtils#remove(list, options = {})

- エイリアスで同じ動作
- ファイルを消す
- ディレクトリを指定するとエラー
- listを配列にて指定する事も出来る

#### FileUtils#rm_dir(list, options = {})

- エイリアスで同じ動作
- ディレクトリを消す
- ファイル指定するとエラー
- listを配列にて指定する事も出来る

#### FileUtils#rm_r FileUtils#rm_fr(list, options = {})

- FileUtils#rm_fr は FileUtils#rm_r(list, options = {force: true}) と同じ
- ファイル、ディレクトリを再帰的に消す
- listを配列にて指定する事も出来る

#### FileUtils#touch(list, options = {})

- ファイルの最終変更時刻、アクセス時刻を更新する
- ファイルが存在しなければ新規作成される
- listを配列にて指定する事も出来る

#### FileUtils#mkdir FileUtils#mkdir_p(list, options = {})

- ディレクトリを作る
- pの方はディレクトリが存在してもエラーにならない
- pの方は2階層以上深いディレクトリを指定しても再帰的に作成してくれる
- listを配列にて指定する事も出来る

#### FileUtils#chown(user, group, list, options = {})

- ファイルまたはディレクトリの所有権を変更する
- listを配列にて指定する事も出来る

#### FileUtils#chmod(mode, list, options = {})

- ファイルまたはディレクトリのパーミッションを変更する
- listを配列にて指定する事も出来る

#### FileUtils#ln_s FileUtils#symlink(src, dest, options = {})

- エイリアスで同じ動作
- ファイルまたはディレクトリ(src)のシンボリックリンク(dest)を作成する
- srcに配列を指定した場合
  - destがディレクトリでなければエラー
  - descがディレクトリであれば移動 src[0] => dest/src[0], src[1] => dest/src[1]

#### FileUtils#ln FileUtils#link(src, dest, options = {})

- エイリアスで同じ動作
- ファイルまたはディレクトリ(src)のハードリンク(dest)を作成する
- srcに配列を指定した場合
  - destがディレクトリでなければエラー
  - descがディレクトリであれば移動 src[0] => dest/src[0], src[1] => dest/src[1]

## ネットワーク

この辺りは辛い！けどがんばれ！

#### クラスツリー

- IO
  - BaseSocket
    - IPSocket
      - TCPSocket
        - TCPServer
        - SOCKSSocket
      - UDPSocket
    - UNIXSocket
      - UNIXServer
    - Socket

| IO          | [IOクラス]({% post_url 2017-07-22-Dir-IO-File-Ruby技術者認定試験の書籍写経メモ %}#IOクラス)                                                        |
| BaseSocket  | ソースを表す抽象クラス                                                                                                                             |
| IPSocket    | インターネットドメインソケットの抽象クラス                                                                                                         |
| TCPSocket   | TCP通信を扱うのに適したインターフェイスを提供                                                                                                      |
| TCPServer   | ↑そのサーバ側のソケットのクラス                                                                                                                   |
| SOCKSSocket | TCPSocketをSOCKS対応したクラス（？）使用にはコンパイル時にオプションが必要                                                                         |
| UDPSocket   | UDP通信を扱うのに適したインターフェイスを提供                                                                                                      |
| UNIXSocket  | UNIXドメインソケットによるプロセス間通信を扱うのに適したインターフェイスを提供                                                                     |
| UNIXServer  | ↑そのサーバ側                                                                                                                                     |
| Socket      | ホスト間、プロセス間の通信を行う通信ソケットを扱うクラス。IOクラスを継承しており、IOクラスを同じインターフェイスでデータの送受信を行うことができる |

### TCPServer

- TCPをサーバ用途で使用する
- ブラウザで http:localhost:10080 にアクセスすると文字列を表示する
- なんかChromeだとエラーになる、厳密にエラーを見てるとかそんな感じがする？

```ruby
require "socket"

server = TCPServer.new(10080)

loop do
  client = server.accept # この行でクライアントからの接続を待機する
  client.puts('Hello TCPServer.')
  client.puts(Time.now.strftime('%Y/%m/%d %T %N'))
  client.close
end
```

### TCPSocket

- TCPをクライアント用途で使う
- 上記で作成したTCPServerにアクセスすると文字列が返ってくる

```ruby
require "socket"

socket = TCPSocket.new('localhost', 10080)

while line = socket.gets
  puts line
end
```

## UDPを扱うクラス

- UDPを扱う際にはサーバー、クライアント用の区別はなく、UDPSocketクラスを使う
- TCPに比べ、コネクションレスで伝達ミスの確認をしない為オーバーヘッドが少なく素早い通信が可能
- データの送信ミスがあっても大きな影響がない動画配信などで使われる

UDPSocketクラスのインスタンスの生成を行う

```ruby
UDPSocket.new([socktype])
```

socktype にはアドレスファミリーと呼ばれるネットワークアドレスの種類を指定する

| Socket::AF_INET  | IPv4ネットワーク （デフォ）|
| Socket::AF_INET6 | IPv6ネットワーク           |

定義したソケットをホストのポートに関連付ける

```ruby
socket.bind(host, port)
```

- パケットの受信にBasicSocketに定義されているrecvメソッドを利用する
- ソケットからデータを受け取り文字列として返す　引数には受け取るデータの長さを指定する
- flagsには受信データ処理のオプションを指定する

```ruby
socket.recv(max_packet[, flags])
```

#### UDPSocketを使い、10000ポートでUDP通信を待ち受ける

```ruby
require 'socket'

max_packet = 1024

socket = UDPSocket.new
socket.bind('0.0.0.0', 10000)

print socket.recv(max_packet)
```

- UDPでデータ送信するには2つの方法がある
  - connectメソッド
    - UDPサーバに接続してからsendメソッドを使用する
  - sendメソッド
    - 接続先とポートを指定する
    - 引数のdest_socketaddrはSocket.pack_sockaddr_inを使って生成したソケットアドレス構造体を指定する（？）

#### UDPSocketを使い、10000ポートに対してデータを送信する

- 上記で作成したUDPサーバにアクセスし文字列を表示させる事ができる

```ruby
require 'socket'

socket = UDPSocket.new

socket.send("Hello UDP world.\n", 0, 'localhost', 10000)

socket.close
```

### プロセス間通信を制御するクラス

- UNIXServer, UNIXSocketクラスはの名前の通り、UNIX系OSで使用できるクラスでWindowsでは使用できない
- 通常、プロセスは独立したアドレス空間で動作している為、プロセス間でデータを共有したい場合や情報のやり取りにはプロセス間通信を使用する
- Rubyはプロセス間通信の為にこの2つのクラスを用意している。C言語ではTCP/IPにおけるデータ通信もSocket関数を使いその中で通信方式を指定するが、Rubyでは別のクラスに分離することで用途が明確になっている
- TCPServerとTCPSocketとほぼ同じように使える
- TCPServerではホスト名とポートを指定したが、UNIXServerでは任意のパス名を指定する

#### UNIXServerを使ってプロセス間通信の待ち受けを行う

実行するとカレントディレクトリにソケットファイルが作成される。プロセス間通信はをのソケットを経由して行われる

```ruby
require 'socket'
require 'fileutils'

socket_path = 'test_socket'

# 同名ソケットは削除する
if File.exist?(socket_path)
  FileUtils.rm(socket_path)
end

server = UNIXServer.new(socket_path)

loop do
  client = server.accept # この行でクライアントからの接続を待機する
  client.puts('Hello UNIXServer.')
  client.puts(Time.now.strftime('%Y/%m/%d %T %N'))
  client.close
end
```

#### UNIXSocketを使ってプロセス間通信にてデータの取得を行う

```ruby
require 'socket'

socket_path = 'test_socket'

socket = UNIXSocket.new(socket_path)

print socket.gets
print socket.gets
```

## uri

- uriはURI(Uniform Resouce Identifier、ネットワーク上のリソースを表現)を扱うライブラリ
- uriとurlの事はぐぐれ

#### スキームってなんぞ

プロトコル毎に、どんなふうに並べて書くかの決まり

| スキーム | ユーザ情報        |   | ホスト情報  |   | ポート番号 | パス    |
| https:// | username:password | @ | example.com | : | 21         | /public |

- スキームは管理組織に登録されているものや非公式なスキームもある
- Rubyが対応しているスキーム http https ftp ldap ldaps mailto
- これらのスキームのパーサは自分でどのスキームなのか判断し、パーサしてくれる

#### URI.parse(uri_string) URI(uri_string)

- スキームがhttpなので、内部ではURI::HTTPクラスのパーサが個々の要素に分割する
- RFCの規格に従って厳格にパースする為、使用できない文字などが含まれていたりするとエラーを返す
- URL(uri_string) は内部で URI.parse(uri_string) を呼び出す

```ruby
require 'uri'

uri = URI.parse('http://username:pass@example.com:80/index.html')

uri.scheme   #=> "http"
uri.user     #=> "username"
uri.password #=> "pass"
uri.host     #=> "example.com"
uri.port     #=> 80
uri.path     #=> "/index.html"
```

#### URI.split(url_string)

[scheme, userinfo, host, port, registory, path, opaque, query, fragment] を返す

```ruby
require 'uri'

p URI.split('http://username:pass@example.com:80/index.html')
=> ["http", "username:pass", "example.com", "80", nil, "/index.html", nil, nil, nil]
```

#### URI.escape(string) URI.encode(string)

- URIで使用できるASCII以外の文字データは16進数で表記したバイトコードを[%xx]という形で表記するように定義されている
- デフォルトの文字エンコードによってエンコードされる
- エンコードを指定する場合は先に変換しておく必要がある
- 引数のunsafeにはURIに使用できない文字を指定するが、デフォルトで使用される URI::UNSAFE で十分であり、通常指定する必要な無い

```ruby
require 'uri'

p URI.encode('http://example.com/モコ')
=> "http://example.com/%E3%83%A2%E3%82%B3"

p URI.encode('http://example.com/モコ'.encode('EUC-JP'))
=> "http://example.com/%A5%E2%A5%B3"
```

#### URI.unescape(str) URI.decode(str)

- URLエンコードされた文字列を元の文字列に戻す
- 「このメソッドは obsolete です。代わりに CGI.unescape, URI.decode_www_form, URI.decode_www_form_component などの使用を検討してください」だそうです

```ruby
require 'uri'

p URI.decode('http://example.com/%E3%83%A2%E3%82%B3')
=> "http://example.com/モコ"

p URI.unescape('http://example.com/%A5%E2%A5%B3').force_encoding('EUC-JP').encode('UTF-8')
"http://example.com/モコ"
```


















EOF
