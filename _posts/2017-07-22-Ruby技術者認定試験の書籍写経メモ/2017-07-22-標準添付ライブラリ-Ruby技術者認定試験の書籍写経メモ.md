## 標準添付ライブラリ

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-Ruby技術者認定試験の書籍写経メモ %})

- 標準添付ライブラリはRubyに付属しているライブラリ
- 組み込みライブラリと違う点はrequire等でライブラリをロードする必要がある
- Ruby技術者認定試験の出題範囲はGold

```ruby
pp []
=> NoMethodError: undefined method 'pp'

require 'pp'
=> true

pp []
[]
=> []
```

## StringIO

- 文字列をIOクラスと同じインターフェイスで取り扱う為のクラス
- IOクラスとの継承関係はないオブジェクト内のバッファに文字列を格納したり取り出したりする

#### バッファとポインタ

あれ？（少なくとも）Ruby2.4ではrequireしなくても使えたわ

| バッファ | StringIO#string | デフォは "" |
| ポインタ | StringIO#pos    | デフォは 0  |

```ruby
sio = StringIO.new

sio.string
=> ""

sio.pos
=> 0
```

- StringIO#string は設定も取得もできる
- 設定するとポインタは0に戻るっぽい（modeによるのかも）

```ruby
sio = StringIO.new

sio.string
=> ""

sio.pos
=> 0

sio.string = '12345'

sio.pos
=> 0

sio.gets
=> "12345"

sio.pos
=> 5
```

#### StringIO#puts

- 引数の文字列をバッファへ格納し、ポインタを移動する
- 格納されるバッファには改行が付加される（put系ぽい）
- ポインタはバッファ上にて追加された文字列と改行の後に移動する

```ruby
sio = StringIO.new
=> #<StringIO:0x007fdf310478c0>

sio.puts('12345')
=> nil

sio.string
=> "12345\n"

sio.pos
=> 6
```

#### StringIO#gets

- 現在のポインタから改行（もしくは末尾）までの文字列を返し、ポインタを移動する
- 返される文字列には改行が付加される（put系ぽい）
- ポインタはバッファ上にて、返した文字列と改行の後に移動する

```ruby
sio = StringIO.new
=> #<StringIO:0x007fdf310478c0>

sio.puts('12')
sio.puts('34')

sio.string
=> "12\n34\n"

sio.pos
=> 6

sio.gets
=> nil

sio.pos = 0

sio.gets
=> "12\n"

sio.pos
=> 3
```

#### インスタンス生成

| new  | インスタンスを返す                  |
| open | ブロックの評価結果を返す            |
| open | ブロックを取らない場合は new と同じ |

```ruby
StringIO.new(string = '', mode = 'r+')
StringIO.open(string = '', mode = 'r+')
StringIO.open(string = '', mode = 'r+') { |sio| ... }
```

#### mode r

- 読み込みモード
- ポインタは先頭を指す

```ruby
StringIO.open('1234', 'r') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('a')
  #=> IOError: not opened for writing
end
=> "string:1234, pos:0"
```

#### mode w

- 書き込みモード
- バッファは空になる
- 当然ポインタは先頭

```ruby
StringIO.open('1234', 'w') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  p sio.gets
  #=> IOError: not opened for reading
end
=> "string:, pos:0"
```

#### mode a

- 書き込みモード
- ポインタは末尾を指す
- ・・ポインタは末尾じゃなくて0を指しているように見えるけど、putsしたら末尾に出力するし、ポインタも末尾に移動したんでまぁいいか

```ruby
StringIO.open('1234', 'a') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:1234AB\n, pos:7"
```

#### mode r+

- 読み書きモード
- ポインタは先頭を指す

```ruby
StringIO.open('1234', 'r+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:AB\n4, pos:3"
```

#### mode w+

- 読み書きモード
- バッファは空になる

```ruby
StringIO.open('1234', 'w+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:, pos:0"
```

#### mode a+

- 読み書きモード
- ポインタは末尾を指す
- ・・ポインタは末尾じゃなくて0を指しているように見えるけど、putsしたら末尾に出力するし、ポインタも末尾に移動したんでまぁいいか

```ruby
StringIO.open('1234', 'a+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:1234AB\n, pos:7"
```

#### StringIO#putc

- 現在のポインタの位置に1文字だけ書き込む
- 引数に2文字以上を渡しても先頭以外は無視される
- もちろんポインタは1つずれる

```ruby
StringIO.open('1234', 'r+') do |sio|
  sio.pos = 2
  p sio.putc('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:12A4, pos:3"
```

#### String#print StringIO#puts

- String#print と StringIO#puts は殆ど同じ動作をする（どうやらウソのようです）
- 末尾に改行を付加するかどうかが違う
- 複数の引数、もしくは配列を取る

```ruby
StringIO.open do |sio|
  p sio.puts('A', 'B')
  p sio.puts(['C', 'D'])
  p sio.print(['E', 'F'])
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:A\nB\nC\nD\n[\"E\", \"F\"], pos:18"
```

#### StringIO#printf

まぁいつものアレ

```ruby
StringIO.open do |sio|
  p sio.printf('%02d', 1)
  p "string:#{sio.string}, pos:#{sio.pos}"
end
"string:01, pos:2"
```

#### StringIO#read

- 現在のポインタから引数に指定した文字数分、文字を取り出す
  - その前に終端になったらそこまで返す
- 既にポインタが終端を指していたら nil を返す
- 第1引数を省略したなら
  - 終端までを返す
  - 既にポインタが終端だったら空文字が返る
- 第2引数を指定したらその変数に取り出した文字列を格納する（あたまおかしい？）

ぶっちゃけややこしい

```ruby
StringIO.open('1234') do |sio|
  p sio.read
end
=> "1234"
```

```ruby
StringIO.open('1234') do |sio|
  sio.pos = 2
  p sio.read
end
=> "34"
```

```ruby
StringIO.open('1234') do |sio|
  sio.pos = 2
  p sio.read(1)
end
=> "3"
```

#### StringIO#getc StringIO#readchar

現在のポインタから1文字取得する

```ruby
StringIO.open('123') do |sio|
  sio.pos = 1
  p sio.getc
  p sio.getc
  p sio.getc
end
=> "2"
=> "3"
=> nil
```

readchar は似たような動作だが、終端でエラーが発生する

```ruby
StringIO.open('123') do |sio|
  sio.pos = 1
  p sio.readchar
  p sio.readchar
  p sio.readchar
end
=> "2"
=> "3"
=> EOFError: end of file reached
```

#### StringIO#gets StringIO#readline

現在のポインタから改行までの文字列を取得する

```ruby
StringIO.open("123\n456") do |sio|
  sio.pos = 1
  p sio.gets
  p sio.gets
  p sio.gets
end
=> "23\n"
=> "456"
=> nil
```

readline は似たような動作だが、終端でエラーが発生する

```ruby
StringIO.open("123\n456") do |sio|
  sio.pos = 1
  p sio.readline
  p sio.readline
  p sio.readline
end
=> "23\n"
=> "456"
=> EOFError: end of file reached
```

#### StringIO#pos= StringIO#seek

ポインタを移動する

- pos= は先頭を0とした絶対位置に移動する（マイナスは指定できないぽい）
- seek は第2引数を基準として相対位置に移動する
  - IO::SEEK_SET ファイル先頭（デフォ）
  - IO::SEEK_CUR 現在のポインタ位置
  - IO::SEEK_END ファイル末尾

```ruby
StringIO.open("123\n456") do |sio|
  sio.seek(-2, IO::SEEK_END)
  p sio.getc
end
=> "5"
```

## YAML

- 簡単な記法でデータの階層構造を表記できるフォーマット
- ハッシュ・配列の組み合わせをスペース・インデントで表現する

```ruby
require 'yaml'

yaml_data = <<-DATA
data_array:
  - a
  - b
  - c
data_key_value:
  key1: value1
  key2: value2
DATA

yaml = YAML.load(yaml_data)
=> {"data_array"=>["a", "b", "c"], "data_key_value"=>{"key1"=>"value1", "key2"=>"value2"}}

yaml.class
=> Hash
```

#### YAML.load_file

ファイルを直接読み込んでオブジェクトを生成する

```ruby
require 'yaml'

YAML.load_file('path/to/yaml_file')
```

### YAML.load_stream

- --- までが一つのデータの区切りとみなされ、通常(YAML.load等)は以降は無視される
- が、YAML.load_stream はデータを順番にYAML::stream で返す
- ・・・らしいが、何かそんなインスタンスじゃないのが返って来るんだけど？ 文字列を渡した時とIOインスタンスを渡した時で変わる？

```ruby
require 'yaml'

yaml_data = <<-DATA
- a
---
- b
DATA

yaml = YAML.load(yaml_data)
=> ["a"]

yaml.class
=> Array

yaml = YAML.load_stream(yaml_data)
=> [["a"], ["b"]]

yaml.class
=> Array
```

IOインスタンスを渡す方が実際の使い方？

```ruby
yaml = YAML.load_stream(open('path/to/yaml_file'))
```

#### YAML.load_document

こんなことも出来るらしいけど、ホントこの書籍はやる気ないわ　俺のやる気も失せるわ

```ruby
YAML.load_document(open('path/to/yaml_file')) do |yaml|
  yaml.first
end
```

#### YAML.dump

オブジェクトをyaml形式の文字列にして返す

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

YAML.dump(moko)
=> "---\n:homo: true\n:homos:\n- :a\n- :b\n"
```

第2引数にIOオブジェクトを渡すとそちらに書き込む

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

sio = StringIO.new

YAML.dump(moko, sio)

sio.string
=> "---\n:homo: true\n:homos:\n- :a\n- :b\n"
```

#### YAML.dump_stream

- 複数のオブジェクトを引数に取れる
- からなんだってんだよな

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

YAML.dump_stream(moko, moko.dup)
=> "---\n:homo: true\n:homos: &1\n- :a\n- :b\n---\n:homo: true\n:homos: *1\n"
```

## JSON

- Ruby1.9から標準添付ライブラリに追加された
- YAMLみたいに簡単な記法でデータの階層構造を表現できる
- to_str, to_io, readメソッドを持つオブジェクトなら文字列以外も渡せる（えーと？）

#### JSON.parse JSON.load

```ruby
require 'json'

json_data = <<-DATA
{"homo": true, "homos": ["a", "b"]}
DATA

json = JSON.parse(json_data)
=> {"homo"=>true, "homos"=>["a", "b"]}

json.class
=> Hash
```

JSON.parse は第2引数に 要素を読み込む毎のオプションがあったりする

- max_nesting : 入れ子になっているデータの最大の深さを指定
- symbolize_names: 真を指定するとハッシュのキーを文字列ではなくシンボルに

JSON.load は第2引数に 要素を読み込む毎に呼び出されるProcオブジェクトを渡せる
渡した所で何の役に立つのか謎
今回の例で言うと配列を順番に渡し、最後に配列を渡す。jsonの評価結果に影響を及ぼさないなら何の意味が・・？

```ruby
require 'json'

json_data = <<-DATA
[1, 2]
DATA

json = JSON.load(json_data, lambda { |i| p i * 2 })
=> 2
=> 4
=> [1, 2, 1, 2]
=> [1, 2]

json
=> [1, 2]
```

#### JSON.parse(IO)

JSON.load_file 的なメソッドは用意されていないが、IOから読み込むことが出来る

```ruby
require 'json'

File.open('path/to/json_file') do |f|
  JSON.load(f)
end
```

```ruby
require 'json'

sio = StringIO.new('["a", "b"]')

JSON.load(sio)
=> ["a", "b"]
```

#### JSON.dump(object, io = nil, imit = nil)
- 第2引数を省略すると文字列として取得
  - ioを指定するとIOに書き込む
- 第3引数limitはダンプするオブジェクトの深さを制限することが出来る

```ruby
require 'json'

sio = StringIO.new()

JSON.dump({hoge: ["a", "b"]}, sio)

sio.string
=> "{\"hoge\":[\"a\",\"b\"]}"
```

## CSV

#### CSV.parse

- CSV.parse(csv_data)
- CSV.parse(csv_data) { |row| ... }

ブロックを渡すと行毎に処理ができる
 
```ruby
require 'csv'

csv_data = <<-DATA
a,b,c
d,e,f
DATA

csv = CSV.parse(csv_data)
=> [["a", "b", "c"], ["d", "e", "f"]]
```

```ruby
require 'csv'

csv_data = <<-DATA
a,b,c
d,e,f
DATA

csv = CSV.parse(csv_data) do |row|
  p row
end
=> ["a", "b", "c"]
=> ["d", "e", "f"]
```

#### CSV.open

- CSV.open('path/to/csv_file', option = {})
- CSV.open('path/to/csv_file', option = {}) { |row| ... }
- CSV.open('path/to/csv_file', mode = 'rb', option = {})
- CSV.open('path/to/csv_file', mode = 'rb', option = {}) { |row| ... }


- ブロックを渡すと行毎に処理ができる
- オプションで改行コードを指定したりできる

### mode

| r  | 読み込み         |
| w  | 書き込み         |
| rb | バイナリ書き込み |
| wb | バイナリ書き込み |

```ruby
require 'csv'

CSV.open('path/to/csv_file') do |row|
  row.each do |col|
    col
  end
end
```

#### CSVデータの書き込み

ブロックを渡すパターンと渡さないパターン

```ruby
require 'csv'

CSV.open('temp1.csv', 'w') do |row|
  row << [1, 2, 3, 4]
  row << [5, 6, 7, 8]
end

csv = CSV.open('temp2.csv', 'w')
csv << [1, 2, 3]
csv << [4, 5, 6]
csv.close
```

```sh
$ cat temp1.csv
1,2,3,4
5,6,7,8

$ cat temp2.csv
1,2,3
4,5,6
```

## CSV.foreach CSV.read CSV.readlines

- CSV.foreach ブロック引数にEnumeratorオブジェクトで各行を受け取る
- CSV.read CSV.readlines 内部の処理は違うが結局は配列の配列を受け取る

正直、何のために複数のメソッドになっているのか謎

## FileUtils

- 基本的なファイル操作を集めたライブラリ
- ファイルやディレクトリの操作はDirやFileでも行えるが、FileUtilsはUNIXコマンドライクに呼び出しやすく扱いやすくしたもの
- だからこそ、どっちを使うのか、今どっちを使っているのかちゃんと意識すべし
- FileUtilsはモジュール関数として実装されているのでincludeしてもよし
- 殆どのコマンドはoptionとして (noop: true(実際には実行しない), verbose: true(詳細をコンソール表示)) 等が渡せる 
- ぶっちゃけ ファイル、ディレクトリ操作は FileUtils を使えばいいんだよ

#### FileUtils.cd(dir, options = {})

カレントディレクトリを引数dirに変更する
ブロックを渡すとブロック内部のみカレントディレクトリが変わる

#### FileUtils.pwd

カレントディレクトリを文字列で返す

```ruby
require 'fileutils'

FileUtils.pwd
=> "/Users/mokoaki/xxxx/xxxx"

FileUtils.cd('/Users') do |a|
  p a
  p FileUtils.pwd
end
=> "/Users"
=> "/Users"

FileUtils.pwd
=> "/Users/mokoaki/xxxx/xxxx"
```

#### FileUtils.cp FileUtils.copy(src, dest, options = {})

- エイリアスで同じ動作
- ファイルをコピーする
- srcがファイルでなければエラー
- destがファイルならそのファイルとして上書き、destがディレクトリならそのディレクトリ以下にsrcをコピーする

#### FileUtils.cp_r(src, dest, options = {})

- 再帰的にファイルをコピーする
- srcをdestにコピーする
- srcがディレクトリであったら再帰的にコピーする
- destがディレクトリならdest/srcにコピーする
- srcを配列にて指定する事も出来る

#### FileUtils.mv FileUtils.move(src, dest, options = {})

- エイリアスで同じ動作
- ファイルを移動する　あれ？ディレクトリは？
- srcを配列にて指定する事も出来る
- srcが1つの場合
  - descが存在しない場合、それがファイル名であるかのように移動される
  - descが存在する
    - descがディレクトリの場合、srcをdest/srcに移動する
    - descがファイルの場合、上書きする
- srcに配列を指定した場合
  - destがディレクトリでなければエラー
  - descがディレクトリであれば移動 src[0] => dest/src[0], src[1] => dest/src[1]

ぶっちゃけややこしい！

#### FileUtils#rm FileUtils#remove(list, options = {})

- エイリアスで同じ動作
- ファイルを消す
- ディレクトリを指定するとエラー
- listを配列にて指定する事も出来る

#### FileUtils#rm_dir(list, options = {})

- エイリアスで同じ動作
- ディレクトリを消す
- ファイル指定するとエラー
- listを配列にて指定する事も出来る

#### FileUtils#rm_r FileUtils#rm_fr(list, options = {})

- FileUtils#rm_fr は FileUtils#rm_r(list, options = {force: true}) と同じ
- ファイル、ディレクトリを再帰的に消す
- listを配列にて指定する事も出来る

#### FileUtils#touch(list, options = {})

- ファイルの最終変更時刻、アクセス時刻を更新する
- ファイルが存在しなければ新規作成される
- listを配列にて指定する事も出来る

#### FileUtils#mkdir FileUtils#mkdir_p(list, options = {})

- ディレクトリを作る
- pの方はディレクトリが存在してもエラーにならない
- pの方は2階層以上深いディレクトリを指定しても再帰的に作成してくれる
- listを配列にて指定する事も出来る

#### FileUtils#chown(user, group, list, options = {})

- ファイルまたはディレクトリの所有権を変更する
- listを配列にて指定する事も出来る

#### FileUtils#chmod(mode, list, options = {})

- ファイルまたはディレクトリのパーミッションを変更する
- listを配列にて指定する事も出来る

#### FileUtils#ln_s FileUtils#symlink(src, dest, options = {})

- エイリアスで同じ動作
- ファイルまたはディレクトリ(src)のシンボリックリンク(dest)を作成する
- srcに配列を指定した場合
  - destがディレクトリでなければエラー
  - descがディレクトリであれば移動 src[0] => dest/src[0], src[1] => dest/src[1]

#### FileUtils#ln FileUtils#link(src, dest, options = {})

- エイリアスで同じ動作
- ファイルまたはディレクトリ(src)のハードリンク(dest)を作成する
- srcに配列を指定した場合
  - destがディレクトリでなければエラー
  - descがディレクトリであれば移動 src[0] => dest/src[0], src[1] => dest/src[1]

## ネットワーク

この辺りは辛い！けどがんばれ！

#### クラスツリー

- IO
  - BaseSocket
    - IPSocket
      - TCPSocket
        - TCPServer
        - SOCKSSocket
      - UDPSocket
    - UNIXSocket
      - UNIXServer
    - Socket

| IO          | [IOクラス]({% post_url 2017-07-22-Dir-IO-File-Ruby技術者認定試験の書籍写経メモ %}#IOクラス)                                                        |
| BaseSocket  | ソースを表す抽象クラス                                                                                                                             |
| IPSocket    | インターネットドメインソケットの抽象クラス                                                                                                         |
| TCPSocket   | TCP通信を扱うのに適したインターフェイスを提供                                                                                                      |
| TCPServer   | ↑そのサーバ側のソケットのクラス                                                                                                                   |
| SOCKSSocket | TCPSocketをSOCKS対応したクラス（？）使用にはコンパイル時にオプションが必要                                                                         |
| UDPSocket   | UDP通信を扱うのに適したインターフェイスを提供                                                                                                      |
| UNIXSocket  | UNIXドメインソケットによるプロセス間通信を扱うのに適したインターフェイスを提供                                                                     |
| UNIXServer  | ↑そのサーバ側                                                                                                                                     |
| Socket      | ホスト間、プロセス間の通信を行う通信ソケットを扱うクラス。IOクラスを継承しており、IOクラスを同じインターフェイスでデータの送受信を行うことができる |

## TCPServer

```ruby
require "socket"

server = TCPServer.new(10080)

loop do
  client = server.accept
  client.puts('Hello TCPServer.')
  client.puts(Time.now)
  client.close
end
```

うごかねえ・・


EOF
