## 標準添付ライブラリ

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-Ruby技術者認定試験の書籍写経メモ %})

- 標準添付ライブラリはRubyに付属しているライブラリ
- 組み込みライブラリと違う点はrequire等でライブラリをロードする必要がある
- Ruby技術者認定試験の出題範囲はGold

```ruby
pp []
=> NoMethodError: undefined method 'pp'

require 'pp'
=> true

pp []
[]
=> []
```

## StringIO

- 文字列をIOクラスと同じインターフェイスで取り扱う為のクラス
- IOクラスとの継承関係はないオブジェクト内のバッファに文字列を格納したり取り出したりする

#### バッファとポインタ

あれ？（少なくとも）Ruby2.4ではrequireしなくても使えたわ

| バッファ | StringIO#string | デフォは "" |
| ポインタ | StringIO#pos    | デフォは 0  |

```ruby
sio = StringIO.new

sio.string
=> ""

sio.pos
=> 0
```

- StringIO#string は設定も取得もできる
- 設定するとポインタは0に戻るっぽい（modeによるのかも）

```ruby
sio = StringIO.new

sio.string
=> ""

sio.pos
=> 0

sio.string = '12345'

sio.pos
=> 0

sio.gets
=> "12345"

sio.pos
=> 5
```

#### StringIO#puts

- 引数の文字列をバッファへ格納し、ポインタを移動する
- 格納されるバッファには改行が付加される（put系ぽい）
- ポインタはバッファ上にて追加された文字列と改行の後に移動する

```ruby
sio = StringIO.new
=> #<StringIO:0x007fdf310478c0>

sio.puts('12345')
=> nil

sio.string
=> "12345\n"

sio.pos
=> 6
```

#### StringIO#gets

- 現在のポインタから改行（もしくは末尾）までの文字列を返し、ポインタを移動する
- 返される文字列には改行が付加される（put系ぽい）
- ポインタはバッファ上にて、返した文字列と改行の後に移動する

```ruby
sio = StringIO.new
=> #<StringIO:0x007fdf310478c0>

sio.puts('12')
sio.puts('34')

sio.string
=> "12\n34\n"

sio.pos
=> 6

sio.gets
=> nil

sio.pos = 0

sio.gets
=> "12\n"

sio.pos
=> 3
```

#### インスタンス生成

| new  | インスタンスを返す                  |
| open | ブロックの評価結果を返す            |
| open | ブロックを取らない場合は new と同じ |

```ruby
StringIO.new(string = '', mode = 'r+')
StringIO.open(string = '', mode = 'r+')
StringIO.open(string = '', mode = 'r+') { |sio| ... }
```

#### mode r

- 読み込みモード
- ポインタは先頭を指す

```ruby
StringIO.open('1234', 'r') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('a')
  #=> IOError: not opened for writing
end
=> "string:1234, pos:0"
```

#### mode w

- 書き込みモード
- バッファは空になる
- 当然ポインタは先頭

```ruby
StringIO.open('1234', 'w') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  p sio.gets
  #=> IOError: not opened for reading
end
=> "string:, pos:0"
```

#### mode a

- 書き込みモード
- ポインタは末尾を指す
- ・・ポインタは末尾じゃなくて0を指しているように見えるけど、putsしたら末尾に出力するし、ポインタも末尾に移動したんでまぁいいか

```ruby
StringIO.open('1234', 'a') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:1234AB\n, pos:7"
```

#### mode r+

- 読み書きモード
- ポインタは先頭を指す

```ruby
StringIO.open('1234', 'r+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:AB\n4, pos:3"
```

#### mode w+

- 読み書きモード
- バッファは空になる

```ruby
StringIO.open('1234', 'w+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:, pos:0"
```

#### mode a+

- 読み書きモード
- ポインタは末尾を指す
- ・・ポインタは末尾じゃなくて0を指しているように見えるけど、putsしたら末尾に出力するし、ポインタも末尾に移動したんでまぁいいか

```ruby
StringIO.open('1234', 'a+') do |sio|
  p "string:#{sio.string}, pos:#{sio.pos}"
  sio.puts('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:1234, pos:0"
=> "string:1234AB\n, pos:7"
```

#### StringIO#putc

- 現在のポインタの位置に1文字だけ書き込む
- 引数に2文字以上を渡しても先頭以外は無視される
- もちろんポインタは1つずれる

```ruby
StringIO.open('1234', 'r+') do |sio|
  sio.pos = 2
  p sio.putc('AB')
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:12A4, pos:3"
```

#### String#print StringIO#puts

- String#print と StringIO#puts は殆ど同じ動作をする（どうやらウソのようです）
- 末尾に改行を付加するかどうかが違う
- 複数の引数、もしくは配列を取る

```ruby
StringIO.open do |sio|
  p sio.puts('A', 'B')
  p sio.puts(['C', 'D'])
  p sio.print(['E', 'F'])
  p "string:#{sio.string}, pos:#{sio.pos}"
end
=> "string:A\nB\nC\nD\n[\"E\", \"F\"], pos:18"
```

#### StringIO#printf

まぁいつものアレ

```ruby
StringIO.open do |sio|
  p sio.printf('%02d', 1)
  p "string:#{sio.string}, pos:#{sio.pos}"
end
"string:01, pos:2"
```

#### StringIO#read

- 現在のポインタから引数に指定した文字数分、文字を取り出す
  - その前に終端になったらそこまで返す
- 既にポインタが終端を指していたら nil を返す
- 第1引数を省略したなら
  - 終端までを返す
  - 既にポインタが終端だったら空文字が返る
- 第2引数を指定したらその変数に取り出した文字列を格納する（あたまおかしい？）

ぶっちゃけややこしい

```ruby
StringIO.open('1234') do |sio|
  p sio.read
end
=> "1234"
```

```ruby
StringIO.open('1234') do |sio|
  sio.pos = 2
  p sio.read
end
=> "34"
```

```ruby
StringIO.open('1234') do |sio|
  sio.pos = 2
  p sio.read(1)
end
=> "3"
```

#### StringIO#getc StringIO#readchar

現在のポインタから1文字取得する

```ruby
StringIO.open('123') do |sio|
  sio.pos = 1
  p sio.getc
  p sio.getc
  p sio.getc
end
=> "2"
=> "3"
=> nil
```

readchar は似たような動作だが、終端でエラーが発生する

```ruby
StringIO.open('123') do |sio|
  sio.pos = 1
  p sio.readchar
  p sio.readchar
  p sio.readchar
end
=> "2"
=> "3"
=> EOFError: end of file reached
```

#### StringIO#gets StringIO#readline

現在のポインタから改行までの文字列を取得する

```ruby
StringIO.open("123\n456") do |sio|
  sio.pos = 1
  p sio.gets
  p sio.gets
  p sio.gets
end
=> "23\n"
=> "456"
=> nil
```

readline は似たような動作だが、終端でエラーが発生する

```ruby
StringIO.open("123\n456") do |sio|
  sio.pos = 1
  p sio.readline
  p sio.readline
  p sio.readline
end
=> "23\n"
=> "456"
=> EOFError: end of file reached
```

#### StringIO#pos= StringIO#seek

ポインタを移動する

- pos= は先頭を0とした絶対位置に移動する（マイナスは指定できないぽい）
- seek は第2引数を基準として相対位置に移動する
  - IO::SEEK_SET ファイル先頭（デフォ）
  - IO::SEEK_CUR 現在のポインタ位置
  - IO::SEEK_END ファイル末尾

```ruby
StringIO.open("123\n456") do |sio|
  sio.seek(-2, IO::SEEK_END)
  p sio.getc
end
=> "5"
```

## YAML

- 簡単な記法でデータの階層構造を表記できるフォーマット
- ハッシュ・配列の組み合わせをスペース・インデントで表現する

```ruby
require 'yaml'

yaml_data = <<-DATA
data_array:
  - a
  - b
  - c
data_key_value:
  key1: value1
  key2: value2
DATA

yaml = YAML.load(yaml_data)
=> {"data_array"=>["a", "b", "c"], "data_key_value"=>{"key1"=>"value1", "key2"=>"value2"}}

yaml.class
=> Hash
```

#### YAML.load_file

ファイルを直接読み込んでオブジェクトを生成する

```ruby
require 'yaml'

YAML.load_file('path/to/yaml_file')
```

### YAML.load_stream

- --- までが一つのデータの区切りとみなされ、通常(YAML.load等)は以降は無視される
- が、YAML.load_stream はデータを順番にYAML::stream で返す
- ・・・らしいが、何かそんなインスタンスじゃないのが返って来るんだけど？ 文字列を渡した時とIOインスタンスを渡した時で変わる？

```ruby
require 'yaml'

yaml_data = <<-DATA
- a
---
- b
DATA

yaml = YAML.load(yaml_data)
=> ["a"]

yaml.class
=> Array

yaml = YAML.load_stream(yaml_data)
=> [["a"], ["b"]]

yaml.class
=> Array
```

IOインスタンスを渡す方が実際の使い方？

```ruby
yaml = YAML.load_stream(open('path/to/yaml_file'))
```

#### YAML.load_document

こんなことも出来るらしいけど、ホントこの書籍はやる気ないわ　俺のやる気も失せるわ

```ruby
YAML.load_document(open('path/to/yaml_file')) do |yaml|
  yaml.first
end
```

#### YAML.dump

オブジェクトをyaml形式の文字列にして返す

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

YAML.dump(moko)
=> "---\n:homo: true\n:homos:\n- :a\n- :b\n"
```

第2引数にIOオブジェクトを渡すとそちらに書き込む

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

sio = StringIO.new

YAML.dump(moko, sio)

sio.string
=> "---\n:homo: true\n:homos:\n- :a\n- :b\n"
```

#### YAML.dump_stream

- 複数のオブジェクトを引数に取れる
- からなんだってんだよな

```ruby
moko = {
  homo: true,
  homos: [
    :a,
    :b,
  ]
}

YAML.dump_stream(moko, moko.dup)
=> "---\n:homo: true\n:homos: &1\n- :a\n- :b\n---\n:homo: true\n:homos: *1\n"
```

## JSON

- Ruby1.9から標準添付ライブラリに追加された
- YAMLみたいに簡単な記法でデータの階層構造を表現できる
- to_str, to_io, readメソッドを持つオブジェクトなら文字列以外も渡せる（えーと？）

#### JSON.parse JSON.load

```ruby
require 'json'

json_data = <<-DATA
{"homo": true, "homos": ["a", "b"]}
DATA

json = JSON.parse(json_data)
=> {"homo"=>true, "homos"=>["a", "b"]}

json.class
=> Hash
```

JSON.parse は第2引数に 要素を読み込む毎のオプションがあったりする

- max_nesting : 入れ子になっているデータの最大の深さを指定
- symbolize_names: 真を指定するとハッシュのキーを文字列ではなくシンボルに

JSON.load は第2引数に 要素を読み込む毎に呼び出されるProcオブジェクトを渡せる
渡した所で何の役に立つのか謎
今回の例で言うと配列を順番に渡し、最後に配列を渡す。jsonの評価結果に影響を及ぼさないなら何の意味が・・？

```ruby
require 'json'

json_data = <<-DATA
[1, 2]
DATA

json = JSON.load(json_data, lambda { |i| p i * 2 })
=> 2
=> 4
=> [1, 2, 1, 2]
=> [1, 2]

json
=> [1, 2]
```

#### JSON.parse(IO)

JSON.load_file 的なメソッドは用意されていないが、IOから読み込むことが出来る

```ruby
require 'json'

File.open('path/to/json_file') do |f|
  JSON.load(f)
end
```

```ruby
require 'json'

sio = StringIO.new('["a", "b"]')

JSON.load(sio)
=> ["a", "b"]
```

#### JSON.dump(object, io = nil, imit = nil)
- 第2引数を省略すると文字列として取得
  - ioを指定するとIOに書き込む
- 第3引数limitはダンプするオブジェクトの深さを制限することが出来る

```ruby
require 'json'

sio = StringIO.new()

JSON.dump({hoge: ["a", "b"]}, sio)

sio.string
=> "{\"hoge\":[\"a\",\"b\"]}"
```

## CSV

- CSV.open('path/to/csv_file', option = {})
- CSV.open('path/to/csv_file', option = {}) { |record| ... }
- CSV.open('path/to/csv_file', mode = 'rb', option = {})
- CSV.open('path/to/csv_file', mode = 'rb', option = {}) { |record| ... }

### mode

| r  | 読み込み         |
| w  | 書き込み         |
| rb | バイナリ書き込み |
| wb | バイナリ書き込み |

```ruby
require 'csv'




```

EOF
