## Gold模擬問題を解いた時に気になったポイントメモ

[Ruby技術者認定試験の書籍写経メモ]({% post_url 2017-07-22-Ruby技術者認定試験の書籍写経メモ %})

### 口癖

- Thread は ねう！ふぉーく！すたあと！
- YAML は ろーど！だんぷ！
- JSON は ろーど！ぱーす！だんぷ！
- 可変長引数は * キーワード引数は **

### スコープ

- ローカル変数には越えられない壁
- class, module, def 定義の境目
  - に越えられない壁は存在する。完全にスコープは隔絶される
- ブロック
  - は外は見える、中は見えないという「例のアレ」
  - ブロックの前にローカル変数が定義されていれば
    - それを使う
  - ブロック内で初めてローカル変数が定義された場合
    - ブロックを抜けた瞬間にそのローカル変数は深淵へと飲み込まれる
    - ブロック外でそのローカル変数にアクセスすると例外
- Proc, lambda
  - クロージャを抱え込む為、超えられないはずの境界を超える

### あまり使われないのに出題される組み込み定数

#### ARGF(ARGVじゃないぞ)

「スクリプトに指定した引数 (Object::ARGV を参照) をファイル名とみなして、 それらのファイルを連結した 1 つの仮想ファイルを表すオブジェクト」

- マジか(´・ω・｀)

./moko1.txt

```txt
moko1 1
moko1 2
```

./moko2.txt

```txt
moko2 1
moko2 2
```

```ruby
# irbではダメ
p ARGF.readlines
```

```sh
$ ruby temp.rb ./moko1.txt ./moko2.txt
#=> ["moko1 1\n", "moko1 2\n", "moko2 1\n", "moko2 2\n"]
```

#### DATA

\__END__ 以降は実行対象にならず、Data(Fileオブジェクト)からアクセスされるデータと成り果てる

```ruby
# irbではダメ
p DATA.readlines
__END__
a
b
c

# => ["a\n", "b\n", "c\n"]
```

### コマンドラインオプション

#### -I(アイ)

- $LOAD_PATH にパスが追加される
- $RUBY_LIB はもちろん変化なし
- require, load する時に検索されるようになる

### require, load

| require | 1度しか読み込まない | 拡張子の補完を行う     | バイナリエクステンションが読み込める   |
| load    | 何度でも読み込む    | 拡張子の補完を行わない | バイナリエクステンションは読み込めない |

#### 可変長引数 キーワード引数 多重代入

これは回数こなして試さないと覚えられないくらいパターンがある

#### Numerable連中の四則演算の結果

- Complex > Float > Rational > Integer

的に変換される Floatは自身に精度がない為にもう一辺の精度を犯すが、Complexだけは特別・・みたいな感じ

### 例外

- NoMethodError < NameError < StandardError < Exception
- raise だけすると StandardError が raise される
- rescue だけすると StandardError が rescue される
- rescue は拾う例外を限定、絞る為に使う
- raise Exception や rescue Exception も可能ではあるが普通はやらない（致命的なエラーを無視、回収してしまう可能性）

### 定義できないメソッド名

| ::                              |
| =(+=, =+, ..等の自己代入演算子) | 
| ? :                             |
| &&                              |
| \|\|                            |
| $で始まるグローバル変数名       |
| 他にはえーと・・                |

- 上記以外は全てメソッド定義可能
- 「再定義できない演算子」と混同してはイケない
- まともに定義できなければ define_method 等でむりやり定義可能
- まともに呼び出せないなら send 等で呼び出し可能
- つまり（普通はしない事だが）下記は可能という事である

```ruby
def def
  'ok'
end

p send(:def)
=> "ok"
```

```ruby
def end
  'ok'
end

p send(:end)
=> "ok"
```

```ruby
def true
  'ok'
end

send(:true)
=> "ok"
```

```ruby
def and
  'ok'
end

send(:and)
=> "ok"
```

```ruby
def if
  'ok'
end

send(:if)
=> "ok"
```

```ruby
def return
  'ok'
end

send(:return)
=> "ok"
```

```ruby
def self
  'ok'
end

send(:self)
=> "ok"
```

```ruby
def send
  'ok'
end

self.send # さすがにsendを潰したのでsendメソッドは使えない
=> "ok"
```

```ruby
def ENV
  'ok'
end

send(:ENV)
=> "ok"
```

```ruby
def __ENCODING__
  'ok'
end

send(:__ENCODING__)
=> "ok"
```

```ruby
define_method(:"'") { 'ok' }

send(:"'")
=> "ok"
```

#### 定数

- メソッド内からの定数の定義・変更は御法度である。 SyntaxError < ScriptError < Exception が発生する
- が、この例外はrescueできなかった。諦めてしまった
- const_set を使用すれば warning は出るが変更は可能となる

#### lambdaを指に覚えさせておく

```ruby
-> (a) { p a }.call(6)
```

```ruby
m = -> (i) { i * 2 }

m.call(4)
=> 8
```

#### catch, throw の動作

catch のブロック内全てを実行したいが・・throw の時点で catch ブロック内の動作を中断する・・ようなイメージ

```ruby
catch(:homo) do
  p 1
  p 2
  throw(:homo)
  p 3
end
1
2
=> nil
```

throw の第2引数が戻り値

```ruby
catch(:homo) do
  p 1
  p 2
  throw(:homo, 'HOMO')
  p 3
end
1
2
=> "HOMO"
```

throwするのがメソッドでもよい。スタックを駆け上る

```ruby
def homo
  throw(:homo, 'HOMO')
end

catch(:homo) do
  p 1
  p 2
  homo
  p 3
end
1
2
=> "HOMO"
```

#### catch, throwのラベルは省略できない

- catch のラベルは省略できる
- throw のラベルは省略できない
- catch のラベルを省略すると throw はどこに戻れば良いか判らないので => 実際問題 catch のラベルを省略する意味がない

### dup, clone 出題される

| clone | 汚染状態、インスタンス変数、ファイナライザ、凍結状態、特異メソッド | を複製する |
| dup   | 汚染状態、インスタンス変数、ファイナライザ                         | を複製する |

### Thread

thread を開始するのは 3つ！コレ出題されるんで注意

ねう！ふぉーく！すたあと！と唱える

| Thread.new   | Threadクラスを継承したサブクラスを開始する時にinitializeを呼ぶ     |
| Thread.fork  | Threadクラスを継承したサブクラスを開始する時にinitializeを呼ばない |
| Thread.start | Threadクラスを継承したサブクラスを開始する時にinitializeを呼ばない |

指で覚える

```ruby
  Thread.new { p 'thread' }
```

```ruby
  Thread.form { p 'thread' }
```

```ruby
  Thread.start { p 'thread' }
```

#### スレッドの中で例外が起こったらどうなるか

- スレッドは警告無しで終了する
- つまり、親から見ると例外は観測できない
- 観測できない事は**「起こっていない」**
- 観測できない事は**「起こっていない」** 大事な事なのでもう一度
- ruby起動時に -d オプションを付けているとスレッド内で例外が発生した時点でインタプリタ自体が終了する

### Fiber

- Fiber は作成した時点では全く動かない
- f.resume により、Fiber.yield まで動作する

```ruby
f = Fiber.new do
  p 'これが表示されたという事は、初回の resume が実行されたという事'
  Fiber.yield('戻り値 1')
  p 'これが表示されたという事は、再度 resume が実行されたという事　まぁ、実行されないんですけどね'
  Fiber.yield('戻り値 2')
  nil
end

p 'START'

sleep 1

p '一息ついてコレが表示される'

result = f.resume

p result

#=> "START"
#=> "一息ついてコレが表示される"
#=> "これが表示されたという事は、初回の resume が実行されたという事"
#=> "戻り値 1"
```

### IOのクラスツリー

| UDPServer は存在しない。そんなもの　ウチには　ないよ                         |
| StringIO は IO のようなインターフェースを持つが、**IO のサブクラスではない** |

- IO
  - BaseSocket
    - IPSocket
      - TCPSocket
        - TCPServer
        - SOCKSSocket
      - UDPSocket
    - UNIXSocket
      - UNIXServer
    - Socket

### Time, Date, DateTime

- require 'date' で Date と DateTime が使えるようになる
- Time は内部的に Float を保持している
- Date, DateTime は内部的に Rational を保持している
- Date, DateTime #to_f メソッドは持っていない（あ、そうなんだ・・程度）
- Date, DateTime #new メソッドでは現在時間でオブジェクトが作成されるわけではない（あ、そうなんだ・・程度）
- ↑Date#today, DateTime.now を使う
- Dateはロケールを持っていない？のでクソ

#### 四則演算

- Time と (Date, DateTime) は演算できない
- Time と Time の差はミリ秒差を Float で取得できる
- (Date, DateTime) と (Date, DateTime) の差を Rarional で取得できる ※(一日を 0〜0.99 で表しているので注意)

```ruby
require 'date'

datetime1 = DateTime.now
sleep 1
datetime2 = DateTime.now

p (datetime2 - datetime1).to_f * 86400
=> 1.002833
```

#### Date, DateTime で出題される気がするメソッド

| - 1  | 前の日 |
| + 1  | 次の日 |
| << 1 | 前の月 |
| >> 1 | 次の月 |

ちなみに

| Time.now + 1  | 1秒後  |
| Time.now << 1 | エラー |

### 何度でも 特殊変数 おさらい

$0, $1, $2... は出題される気がする

- $0 **実行中のプログラムファイル名**
- $1 キャプチャ1つめ
- $2 キャプチャ2つめ
- $3 キャプチャ3つめ

| $0       | 実行中のプログラムファイル名           |
|          |                                        |
| $1       | マッチした1番目のキャプチャ            |
| $2       | マッチした2番目のキャプチャ            |
| $n       | マッチしたn番目のキャプチャ            |
| $+       | マッチした最後のキャプチャ             |
| $~[n]    | 最後に成功したマッチに対する結果       |
|          |                                        |
| $`       | マッチした部分より前の文字列           |
| $&       | マッチした部分                         |
| $'       | マッチした部分より後の文字列           |
|          |                                        |
| $_       | 最後にgetsやreadlineで読み込んだ文字列 |
|          |                                        |
| $:       | $LOAD_PATH                             |
|          |                                        |
| $*       | ARGV                                   |
|          |                                        |
| $?       | 最後に終了した子プロセス               |
| $!       | 直近で補足した例外オブジェクト         |
| $@       | バックトレース                         |

ちなみにネストしたキャプチャは始まった順番に重複して取得可能

```ruby
/(\d(\d(\d)(\d))\d)/ === '12345'
#=> true

p $1 # => "12345"
p $2 # => "234"
p $3 # => "3"
p $4 # => "4"
```

### alias 出題される

大事なのはコレだけ

- alias 新しい名前 古い名前
- カンマは要らない
- シンボルか直接メソッド名を指定する
- 文字列は指定できない

```ruby
class Moko
  def moko
    'moko'
  end

  alias :old_moko :moko
end

Moko.new.old_moko
# => "moko"
```

```ruby
class Moko
  def moko
    'moko'
  end

  alias old_moko moko
  
  def moko
    'new_moko'
  end
end

Moko.new.old_moko
# => "moko"
Moko.new.moko
# => "new_moko"
```

### 定数

- おさらい
- サブクラスでも同じ定数を参照する

```ruby
class Moko1
  @@global = 0

  def initialize
    @@global += 1
  end

  def global
    @@global
  end
end

class Moko2 < Moko1
end

Moko1.new.global # => 1
Moko2.new.global # => 2
```

- 特異クラスからでも同じ定数を参照する
- サブクラスの特異クラスからでも同じ定数を参照する
- 当然、
  - サブクラスの特異クラスにそんなメソッドは無いので
  - 親クラスの特異クラスのメソッドが探索されて
  - 実行されても同じ定数を参照する

```ruby
class Moko1
  @@global = 0

  def initialize
    @@global += 1
  end

  def global
    @@global
  end

  class << self
    def problem1
      @@global += 1
    end
  end
end

class Moko2 < Moko1
  class << self
    def problem2
      @@global += 1
    end
  end
end

Moko1.new.global # => 1
Moko2.new.global # => 2
Moko1.problem1 # => 3
Moko2.problem1 # => 4
Moko2.problem2 # => 5
```

### sort が出題される

- <=> と (a - b) の違い（というか「同じ事をしている」という意識）
- ( ･`ω･´) <= sortさん
  - 「左辺が大きかったら」
    - a <=> b が 1以上
    - (a - b) が 1以上
  - 「左辺と右辺を入れ替えないとね！」

```ruby
[1, 3, 2].sort { |a, b| a <=> b }
# => [1, 2, 3]

[1, 3, 2].sort { |a, b| a - b }
# => [1, 2, 3]
```

おとなしく sort_by 使ってくれればいいのに、いじわるでsortが出題される

```ruby
[1, 3, 2].sort_by { |a| a }
# => [1, 2, 3]
```

### YAML

#### やむるはろーど！だんぷ！

- YAML.load(yaml_string)
- YAML.dump(object, io = STDOUT)

```ruby
require 'yaml'

yaml_string = <<YAML_STRING
moko:
  - hoge1
  - hoge2
  - hoge3:
    - hoge3-1
    - hoge3-2
YAML_STRING

yaml_data = YAML.load(yaml_string)

p yaml_data
# => {"moko"=>["homo1", "homo2"]}

p YAML.dump(yaml_data)
# => "---\nmoko:\n- homo1\n- homo2\n"
```

#### 基本的なルール

##### とりあえずハッシュと配列があればほぼイケる

ハッシュ

```ruby
yaml_string = <<-YAML_STRING
moko: hoge
YAML_STRING

YAML.load(yaml_string)
# => {"moko"=>"hoge"}
```

配列

```txt
yaml_string = <<-YAML_STRING
- hoge1
- hoge2
- hoge3
YAML_STRING

YAML.load(yaml_string)
=> ["hoge1", "hoge2", "hoge3"]
```

組み合わせ

```txt
yaml_string = <<-YAML_STRING
moko:
  - hoge1
  - hoge2
  - hoge3:
    - hoge3-1
    - hoge3-2
YAML_STRING

YAML.load(yaml_string)
=> {"moko"=>["hoge1", "hoge2", {"hoge3"=>["hoge3-1", "hoge3-2"]}]}
```

### JSON

#### じぇいそんはろーど！ぱーす！だんぷ！

- JSON.load(json_string)
- JSON.parse(json_string)
- JSON.dump(json_object, io = nil)
- Hash#to_json
- Array#to_json

```ruby
require 'json'

json_string = <<-JSON_STRING
{"homo": true, "homos": ["a", "b"]}
JSON_STRING

p json_object = JSON.load(json_string) # => {"homo"=>true, "homos"=>["a", "b"]}
p JSON.parse(json_string) # => {"homo"=>true, "homos"=>["a", "b"]}

p JSON.dump(json_object) # => "{\"homo\":true,\"homos\":[\"a\",\"b\"]}"

p ({moko: [1, 2, 3]}.to_json) # => "{\"moko\":[1,2,3]}"
p ([1,2,3, {moko: 1}].to_json) # => "[1,2,3,{\"moko\":1}]"
```

#### 基本的なルール

##### とりあえずハッシュと配列があればほぼイケる

ハッシュ

```ruby
json_string = <<-JSON_STRING
{"moko1": "hoge"}
JSON_STRING

JSON.load(json_string)
# => {"moko1"=>"hoge"}
```

配列

```ruby
json_string = <<-JSON_STRING
[
  "moko1",
  "moko2",
  "moko3"
]
JSON_STRING

JSON.load(json_string)
# => ["moko1", "moko2", "moko3"]
```

組み合わせ

```ruby
json_string = <<-JSON_STRING
{
  "moko1":[
    "hoge1",
    "hoge2",
    {
      "hoge3": [
        "hoge3-1",
        "hoge3-2"
      ]
    }
  ]
}
JSON_STRING

JSON.load(json_string)
# => {"moko1"=>["hoge1", "hoge2", {"hoge3"=>["hoge3-1", "hoge3-2"]}]}
```

### 特異クラスが絡んだ探索経路をおさらい

- 下に書いてあるが
- 定数もメソッドも探索経路は一緒
- クラスのsuperclass
  - [Aを継承したクラス, A, Object, Kernel, BasicObject]
- 特異クラスのsuperclass 長いなー！
  - [Aを継承したクラスの特異クラス, Aの特異クラス, Objectの特異クラス, BasicObjectの特異クラス, Class, Module, Object, Kernel, BasicObject]

定数

```ruby
class A
  A = 'A'

  class << self
    A = 'A_'
  end
end

class B < A
  def check
    A
  end

  class << self
    def check
      A
    end
  end
end

p B.new.check # => '_A'
p B.check # => 'A'
```

メソッド

```ruby
class A
  def check
    'a'
  end

  class << self
    def check
      '_a'
    end
  end
end

class B < A
end

p B.new.check # => 'a'
p B.check # => '_a'

p B.ancestors
# => [B, A, Object, Kernel, BasicObject]

p B.singleton_class.ancestors
# => [#<Class:B>, #<Class:A>, #<Class:Object>, #<Class:BasicObject>, Class, Module, Object, Kernel, BasicObject]
```

#### exit とは

「そこでプログラムを終了する」ではなく SystemExit < Exception 例外を発生させる

```ruby
begin
  exit
rescue SystemExit => e
  p e
  p e.class
  p e.class.superclass
end

# => #<SystemExit: exit>
# => SystemExit
# => Exception
```

ちなみに exit! は例外も発生させずにマジ終了する

```ruby
begin
  exit!
rescue Exception => e
  p e
  p e.class
  p e.class.superclass
end
```

全ての例外を捉えるはずの Exception であっても rescue できずに終了する

### トップレベルのメソッドを定義するということ

- class 定義などの外では、トップレベルに居る、という状態になる
- トップレベルは 「Objectクラスのインスタンスである、main に居る」状態である
- そのため、トップレベルでは self => main となる
- トップレベルでメソッドを定義する、
  - という事は「Objectクラスのインスタンスである main が self である状態でメソッドを定義する」
  - つまり「Objectクラスのインスタンスである main にメソッドを定義する」という事である
  - 通常は privateメソッドとして定義されるが **irb では publicメソッドになる**ので注意
  - irbの場合
  - ```ruby
    Object.public_instance_methods(false)
    # => []

    p Object.private_instance_methods(false)
    # => [:DelegateClass, :default_src_encoding, :irb_binding]

    def moko
      true
    end

    Object.public_instance_methods(false)
    # => [:moko]

    p Object.private_instance_methods(false)
    # => [:DelegateClass, :default_src_encoding, :irb_binding]
    ```
  - 通常スクリプトの場合
  - ```ruby
    p Object.public_instance_methods(false)
    # => []
    p Object.private_instance_methods(false)
    # => [:DelegateClass]

    def moko
      true
    end

    p Object.public_instance_methods(false)
    # => []
    p Object.private_instance_methods(false)
    # => [:DelegateClass, :moko]
    ```
  - あまり重要ではないかもしれないが、Object のインスタンスにメソッドを定義するという事は全てのオブジェクトにメソッドを追加したのと同じという事でもある
  - ```ruby
    def hage
      'hage-!'
    end

    hage
    => "hage-!"

    :aaa.hage
    => "hage-!"
    ```
